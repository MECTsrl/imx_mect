diff --exclude CVS --exclude .git -uNr linux-2.6.35.3/arch/arm/mach-mx28/device.c linux-2.6.35.3.modified/arch/arm/mach-mx28/device.c
--- linux-2.6.35.3/arch/arm/mach-mx28/device.c	2013-05-06 13:04:09.150866803 +0200
+++ linux-2.6.35.3.modified/arch/arm/mach-mx28/device.c	2013-05-06 12:50:04.546866803 +0200
@@ -50,6 +50,7 @@
 #include "mx28evk.h"
 #include "mx28_pins.h"
 #include "linux/gpio_keys.h"
+#include "linux/gpio_pwrfail.h"
 
 #if defined(CONFIG_SERIAL_MXS_DUART) || \
 	defined(CONFIG_SERIAL_MXS_DUART_MODULE)
@@ -1028,7 +1029,12 @@
 	pdev->dev.platform_data = &mxs_kbd_data;
 	mxs_add_device(pdev, 3);
 }
-#elif defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO)
+#elif defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+
+#if (defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)) && (defined(CONFIG_MECT_GPIO_POWERFAIL) || defined(CONFIG_MECT_GPIO_POWERFAIL_MODULE))
+#error Invalid kernel configuration: CONFIG_KEYBOARD_GPIO and CONFIG_MECT_GPIO_POWERFAIL use the same gpio .
+#endif
+
 
 #define GPIO_BUTTON(gpio_num, ev_code, act_low, descr, wake)    \
 {                                                               \
@@ -1042,7 +1048,8 @@
 }
 
 static struct gpio_keys_button gpio_mect_buttons[] = {
-        GPIO_BUTTON(MXS_PIN_TO_GPIO(PINID_SSP3_SCK), KEY_F1, 1, "T1", 0),
+        
+	GPIO_BUTTON(MXS_PIN_TO_GPIO(PINID_SSP3_SCK), KEY_F1, 1, "T1", 0),
         GPIO_BUTTON(MXS_PIN_TO_GPIO(PINID_SSP1_DATA0), KEY_F2, 1, "T2", 0),
         GPIO_BUTTON(MXS_PIN_TO_GPIO(PINID_SSP3_SS0), KEY_F3, 1, "T3", 0),
         GPIO_BUTTON(MXS_PIN_TO_GPIO(PINID_SSP2_MOSI), KEY_F4, 1, "T4", 0),
@@ -1081,6 +1088,48 @@
 }
 #endif
 
+#if defined(CONFIG_MECT_GPIO_POWERFAIL) || defined (CONFIG_MECT_GPIO_POWERFAIL_MODULE)
+
+#define GPIO_SET_ROLE(gpio_num, descr)    			\
+{                                                               \
+        .gpio              = gpio_num,                          \
+        .desc              = descr,                      	\
+								\
+}
+static struct gpio_pwrfail gpio_pwrfails[] = {
+        GPIO_SET_ROLE(MXS_PIN_TO_GPIO(PINID_SSP3_SCK), "24V_disconnection")
+};
+
+static struct gpio_pwrfail_platform_data gpio_pwrfail_data = {
+        .pwrfails        = gpio_pwrfails,
+        .npwrfails       = ARRAY_SIZE(gpio_pwrfails),
+};
+
+static void __init mx28_init_gpio_pwrfail(void)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("gpio-pwrfails", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+	{
+		printk(KERN_INFO "gpio-pwrfails mxs_get_device fail\n");
+		return;
+	}
+	pdev->resource = 0;
+	pdev->num_resources = 0;
+	pdev->dev.platform_data = &gpio_pwrfail_data;
+
+	mxs_add_device(pdev, 3);
+}
+
+#else
+static void __init mx28_init_gpio_pwrfail(void)
+{
+	;
+}
+#endif
+
+
+
 #if defined(CONFIG_TOUCHSCREEN_MXS) || defined(CONFIG_TOUCHSCREEN_MXS_MODULE)
 static struct mxs_touchscreen_plat_data mx28_ts_data = {
 	.x_plus_chan = LRADC_TOUCH_X_PLUS,
@@ -1683,6 +1732,7 @@
 	mx28_init_l2switch();
 	mx28_init_flexcan();
 	mx28_init_kbd();
+	mx28_init_gpio_pwrfail();
 	mx28_init_ts();
 	mx28_init_audio();
 	mx28_init_spdif();
diff --exclude CVS --exclude .git -uNr linux-2.6.35.3/arch/arm/plat-mxs/device.c linux-2.6.35.3.modified/arch/arm/plat-mxs/device.c
--- linux-2.6.35.3/arch/arm/plat-mxs/device.c	2013-05-06 13:04:08.994866807 +0200
+++ linux-2.6.35.3.modified/arch/arm/plat-mxs/device.c	2013-05-06 12:48:22.334866809 +0200
@@ -308,6 +308,16 @@
 };
 #endif
 
+#if defined(CONFIG_MECT_GPIO_POWERFAIL) || defined(CONFIG_MECT_GPIO_POWERFAIL_MODULE)
+static struct platform_device gpio_pwrfail = {
+	.name = "gpio-pwrfails",
+	.id = 0,
+	.dev = {
+		.release = mxs_nop_release,
+		},
+};
+#endif
+
 #if defined(CONFIG_TOUCHSCREEN_MXS) || defined(CONFIG_TOUCHSCREEN_MXS_MODULE)
 static struct platform_device mxs_ts = {
 	.name = "mxs-ts",
@@ -685,6 +695,14 @@
 	 },
 #endif
 
+#if defined(CONFIG_MECT_GPIO_POWERFAIL)
+	{
+	 .name = "gpio-pwrfails",
+	 .size = 1,
+	 .pdev = &gpio_pwrfail,
+	 },
+#endif
+
 #if defined(CONFIG_TOUCHSCREEN_MXS) || defined(CONFIG_TOUCHSCREEN_MXS_MODULE)
 	{
 	 .name = "mxs-ts",
diff --exclude CVS --exclude .git -uNr linux-2.6.35.3/drivers/misc/Kconfig linux-2.6.35.3.modified/drivers/misc/Kconfig
--- linux-2.6.35.3/drivers/misc/Kconfig	2013-05-06 13:04:04.218866803 +0200
+++ linux-2.6.35.3.modified/drivers/misc/Kconfig	2013-04-17 08:47:08.893011958 +0200
@@ -363,6 +363,20 @@
 	depends on ARCH_MX28 || ARCH_MX50
 	default y
 
+config MECT_GPIO_POWERFAIL
+	tristate "POWERFAIL MANAGEMENT GPIO "
+	depends on GENERIC_GPIO
+	help
+	  This driver implements support for powerfail detection connected
+	  to GPIO pins of various CPUs.
+
+	  Say Y here if your device uses GPIO to sense a powerfail event.
+	  Your board-specific setup logic must also provide a platform device,
+	  with configuration data saying which GPIOs are used.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gpio_powerfails.
+
 config ANDROID_PMEM
 	bool "Android pmem allocator"
 	default n
diff --exclude CVS --exclude .git -uNr linux-2.6.35.3/drivers/misc/Makefile linux-2.6.35.3.modified/drivers/misc/Makefile
--- linux-2.6.35.3/drivers/misc/Makefile	2013-05-06 13:04:04.218866803 +0200
+++ linux-2.6.35.3.modified/drivers/misc/Makefile	2013-04-17 08:43:35.893010656 +0200
@@ -30,6 +30,7 @@
 obj-$(CONFIG_IWMC3200TOP)      += iwmc3200top/
 obj-$(CONFIG_MXS_PERSISTENT)	+= mxs-persistent.o
 obj-$(CONFIG_MXS_PERFMON)	+= mxs-perfmon.o
+obj-$(CONFIG_MECT_GPIO_POWERFAIL) +=gpio_pwrfail.o
 obj-y				+= eeprom/
 obj-y				+= cb710/
 obj-$(CONFIG_VMWARE_BALLOON)	+= vmware_balloon.o
diff --exclude CVS --exclude .git -uNr linux-2.6.35.3/drivers/misc/gpio_pwrfail.c linux-2.6.35.3.modified/drivers/misc/gpio_pwrfail.c
--- linux-2.6.35.3/drivers/misc/gpio_pwrfail.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.3.modified/drivers/misc/gpio_pwrfail.c	2013-05-06 12:33:35.147543029 +0200
@@ -0,0 +1,543 @@
+/*
+ * Driver for powerfail detection based on GPIO interrrupt.
+ *
+ * Based on work done by Phil Blundell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/gpio_pwrfail.h>
+#include <linux/gpio.h>
+
+#include <mach/lcdif.h>
+#include <mach/regs-lcdif.h>
+#include <mach/regs-pwm.h>
+#include <mach/regs-power.h>
+#include <mach/pinctrl.h>
+
+
+
+//defines for pheriperal shutdown
+#define REGS_ENET_BASE IO_ADDRESS(ENET_PHYS_ADDR)	
+#define HW_ENET_MAC_ECR	(0x00000024)
+#define BM_ENET_MAC_ECR_SLEEP	(0x00000008)
+
+#define REGS_USBPHY0_BASE	IO_ADDRESS(USBPHY0_PHYS_ADDR)
+#define REGS_USBPHY1_BASE	IO_ADDRESS(USBPHY1_PHYS_ADDR)
+#define HW_USBPHY_CTRL_SET	(0x00000034)
+#define HW_USBPHY_CTRL_CLR	(0x00000038)
+#define BM_USBPHY_CTRL_CLKGATE	0x40000000
+
+#define REGS_CAN0_BASE	IO_ADDRESS(CAN0_PHYS_ADDR)
+#define REGS_CAN1_BASE	IO_ADDRESS(CAN1_PHYS_ADDR)
+#define CAN_HW_REG_MCR		0x00
+#define __MCR_MDIS		(1 << 31)
+
+#define REGS_SSP0_BASE	IO_ADDRESS(SSP0_PHYS_ADDR)
+#define REGS_SSP1_BASE	IO_ADDRESS(SSP1_PHYS_ADDR)
+#define REGS_SSP2_BASE	IO_ADDRESS(SSP2_PHYS_ADDR)
+#define REGS_SSP3_BASE	IO_ADDRESS(SSP3_PHYS_ADDR)
+#define REGS_PERFMON_BASE IO_ADDRESS(PERFMON_PHYS_ADDR)
+#define HW_PERFMON_CTRL_SET (0x00000004)
+#define BM_PERFMON_CTRL_CLKGATE 0x40000000
+#define BM_PERFMON_CTRL_SFTRST 0x80000000
+
+#define RTC_BASE_ADDR IO_ADDRESS(RTC_PHYS_ADDR)	
+
+#define AUART0_BASE_ADDR IO_ADDRESS(AUART0_PHYS_ADDR)
+#define AUART1_BASE_ADDR IO_ADDRESS(AUART1_PHYS_ADDR)
+#define AUART2_BASE_ADDR IO_ADDRESS(AUART2_PHYS_ADDR)
+#define AUART3_BASE_ADDR IO_ADDRESS(AUART3_PHYS_ADDR)
+#define AUART4_BASE_ADDR IO_ADDRESS(AUART4_PHYS_ADDR)
+#define HW_UARTAPP_CTRL0_SET	(0x00000004)
+#define BM_UARTAPP_CTRL0_CLKGATE	0x40000000
+#define BM_UARTAPP_CTRL0_SFTRST	0x80000000
+
+#define PXP_BASE_ADDR 	IO_ADDRESS(PXP_PHYS_ADDR)
+#define HW_PXP_CTRL_SET	(0x00000004)
+#define BM_PXP_CTRL_CLKGATE	0x40000000
+#define BM_PXP_CTRL_SFTRST	0x80000000
+
+#define SAIF0_BASE_ADDR IO_ADDRESS(SAIF0_PHYS_ADDR)
+#define SAIF1_BASE_ADDR IO_ADDRESS(SAIF0_PHYS_ADDR)
+#define HW_SAIF_CTRL_SET	(0x00000004)
+#define BM_SAIF_CTRL_CLKGATE	0x40000000
+#define BM_SAIF_CTRL_SFTRST	0x80000000
+
+#define SPDIF_BASE_ADDR IO_ADDRESS(SPDIF_PHYS_ADDR)
+#define HW_SPDIF_CTRL_SET	(0x00000004)
+#define BM_SPDIF_CTRL_CLKGATE	0x40000000
+#define BM_SPDIF_CTRL_SFTRST	0x80000000
+
+#define HSADC_BASE_ADDR IO_ADDRESS(HSADC_PHYS_ADDR)
+#define HW_HSADC_CTRL0_SET	(0x00000004)
+#define BM_HSADC_CTRL0_CLKGATE	0x40000000
+#define BM_HSADC_CTRL0_SFTRST	0x80000000
+#define HW_HSADC_CTRL2_SET	(0x00000024)
+#define BM_HSADC_CTRL2_POWERDOWN 0x00002000
+
+#define PINID_SSP2_MOSI		MXS_PIN_ENCODE(2, 17)
+#define PINID_AUART2_TX		MXS_PIN_ENCODE(3, 9)
+#define PINID_SSP1_DATA3	MXS_PIN_ENCODE(2, 15)
+
+struct gpio_pwrfail_data {
+	struct gpio_pwrfail *pwrfail;
+	struct work_struct work;
+	bool disabled;
+};
+
+struct gpio_pwrfail_drvdata {
+	unsigned int n_pwrfails;
+	struct gpio_pwrfail_data data[0];
+};
+
+
+
+#ifdef PWRFAIL_SIGNAL
+
+
+struct dentry *file;
+int pid;
+
+struct siginfo pwr_sig_info;
+struct task_struct *t;
+
+static int retentive_shutdown( __attribute__ ((unused)) struct inode *inode,struct file *file,unsigned int cmd,__attribute__ ((unused)) unsigned long arg)
+{
+	int ret = -ENOTTY;
+	
+    if (_IOC_TYPE(cmd) != RETENTIVE_MAGIC)
+        return -ENOTTY;
+
+    if ((_IOC_DIR(cmd) & _IOC_READ) && (!access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd))))
+        return -EFAULT;
+
+    if ((_IOC_DIR(cmd) & _IOC_WRITE) && (!access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd))))
+        return -EFAULT;
+
+    switch (cmd) {
+        case RETENTIVE_POWEROFF:
+	    __raw_writel(0x3e770000, REGS_POWER_BASE + HW_POWER_RESET);
+		/*power down*/
+	    __raw_writel(0x3e770001, REGS_POWER_BASE + HW_POWER_RESET);
+            
+            ret = 0;
+            break;
+#ifdef PWRFAIL_DEBUG
+	case RETENTIVE_GPIOCTRL:
+		gpio_set_value(MXS_PIN_TO_GPIO(PINID_SSP2_MOSI), 1);
+		break;
+#endif
+	default:
+	printk(KERN_WARNING "%s: unknown commmand %d\n", __func__, cmd);
+   }
+   return ret;	
+	
+}
+
+static ssize_t write_pid(struct file *file, const char __user *buf,
+		size_t count, loff_t *ppos)
+{
+	char mybuf[10];
+
+	/* read the value from user space */
+	if(count > 10)
+		return -EINVAL;
+	copy_from_user(mybuf, buf, count);
+	sscanf(mybuf, "%d", &pid);
+	printk(KERN_INFO "pid = %d\n", pid);
+
+	memset(&pwr_sig_info, 0, sizeof(struct siginfo));
+	pwr_sig_info.si_signo = SIGPWRFAIL;
+	pwr_sig_info.si_code = SI_QUEUE;	// this is bit of a trickery: SI_QUEUE is normally used by sigqueue from user space,
+	// and kernel space should use SI_KERNEL. But if SI_KERNEL is used the real_time data 
+	// is not delivered to the user space signal handler function. 
+	pwr_sig_info.si_int = 1234;  		//real time signals may have 32 bits of data.
+
+	rcu_read_lock();
+	t = find_task_by_vpid(pid);  //find the task_struct associated with this pid
+	if(t == NULL){
+		printk("no such pid\n");
+		rcu_read_unlock();
+		return -ENODEV;
+	}
+	rcu_read_unlock();
+
+	return count;
+}
+
+static const struct file_operations my_fops = {
+	.write = write_pid,
+	.ioctl = retentive_shutdown
+};
+
+#endif
+
+
+static void gpio_pwrfail_work_func(struct work_struct *work)
+{
+	struct gpio_pwrfail_data *plat_data = container_of(work, struct gpio_pwrfail_data, work);
+	struct gpio_pwrfail *pwrfail = plat_data->pwrfail;
+	int val;
+	int level = (gpio_get_value(pwrfail->gpio) ? 1 : 0);
+
+#ifdef PWRFAIL_DEBUG
+	printk("PWRFAIL_DEBUG %s: ENTER level %d\n", __func__, level);
+#endif
+
+	if (level) //pwrfail event
+	{
+#ifdef PWRFAIL_SIGNAL
+		
+		if (pid > 0)
+		{
+			//be prepared for a possible 24V hole detection
+			set_irq_type(gpio_to_irq(pwrfail->gpio), IRQ_TYPE_EDGE_FALLING);
+		
+		//usb disable
+			gpio_direction_output(MXS_PIN_TO_GPIO(PINID_AUART2_TX), 0);
+			gpio_set_value(MXS_PIN_TO_GPIO(PINID_AUART2_TX), 0);
+
+		//lan disable 
+#if defined CONFIG_MECT_VAL01
+			gpio_direction_output(MXS_PIN_TO_GPIO(PINID_SSP1_DATA3), 1);
+
+#elif defined CONFIG_MECT_ELE01 || defined CONFIG_MECT_TPAC1006 || defined CONFIG_MECT_U295 || defined CONFIG_MECT_TPAC1006_640x480
+			gpio_direction_output(MXS_PIN_TO_GPIO(PINID_SSP1_DATA3), 1);
+
+#else
+			gpio_direction_output(MXS_PIN_TO_GPIO(PINID_SSP1_DATA3), 1);
+#endif
+
+
+		//stop ethernet
+			//put the controller in sleep mode when asserted 
+			val = __raw_readl(REGS_ENET_BASE + HW_ENET_MAC_ECR);
+			val |= (BM_ENET_MAC_ECR_SLEEP);
+			__raw_writel(val, REGS_ENET_BASE + HW_ENET_MAC_ECR);
+
+
+		//stop LCDIF
+			//__raw_writel(BM_LCDIF_CTRL_CLKGATE, REGS_LCDIF_BASE + HW_LCDIF_CTRL_SET);
+
+
+		//stop bcklight
+			__raw_writel(BF_PWM_ACTIVEn_INACTIVE(0) |
+				     BF_PWM_ACTIVEn_ACTIVE(0),
+				     REGS_PWM_BASE + HW_PWM_ACTIVEn(2));
+			__raw_writel(BF_PWM_PERIODn_CDIV(6) |	/* divide by 64 */
+				     BF_PWM_PERIODn_INACTIVE_STATE(2) |	/* low */
+				     BF_PWM_PERIODn_ACTIVE_STATE(3) |	/* high */
+				     BF_PWM_PERIODn_PERIOD(599),
+				     REGS_PWM_BASE + HW_PWM_PERIODn(2));
+			__raw_writel(BM_PWM_CTRL_PWM2_ENABLE, REGS_PWM_BASE + HW_PWM_CTRL_CLR);
+
+		//usb
+
+			//__raw_writel(BM_USBPHY_CTRL_CLKGATE, REGS_USBPHY0_BASE + HW_USBPHY_CTRL_SET);
+			//__raw_writel(BM_USBPHY_CTRL_CLKGATE, REGS_USBPHY1_BASE + HW_USBPHY_CTRL_SET);
+
+		//can
+		/*	val = __raw_readl(REGS_CAN0_BASE + CAN_HW_REG_MCR);
+			__raw_writel(val | __MCR_MDIS, REGS_CAN0_BASE + CAN_HW_REG_MCR);
+			val = __raw_readl(REGS_CAN1_BASE + CAN_HW_REG_MCR);
+			__raw_writel(val | __MCR_MDIS, REGS_CAN1_BASE + CAN_HW_REG_MCR);
+		*/
+
+#ifdef PWRFAIL_DEBUG
+			printk(" 2pid");
+#endif
+				/* send the signal */
+				if (send_sig_info(SIGPWRFAIL, &pwr_sig_info, t) < 0) {
+					printk(KERN_INFO "error sending signal to pid %d\n", pid);
+				}
+				else
+				{
+#ifdef PWRFAIL_DEBUG
+					printk(" sent");
+#endif		
+				}
+		}
+		else
+		{
+#ifdef PWRFAIL_DEBUG
+		printk(" no_pid");
+#endif			
+		}
+#endif
+
+	}
+	else //we have 24V woking again
+	{
+		set_irq_type(gpio_to_irq(pwrfail->gpio), IRQ_TYPE_EDGE_RISING);
+		
+		//enable USB
+		gpio_direction_output(MXS_PIN_TO_GPIO(PINID_AUART2_TX), 1);
+		gpio_set_value(MXS_PIN_TO_GPIO(PINID_AUART2_TX), 1);
+
+		//__raw_writel(BM_USBPHY_CTRL_CLKGATE, REGS_USBPHY0_BASE + HW_USBPHY_CTRL_CLR);
+		//__raw_writel(BM_USBPHY_CTRL_CLKGATE, REGS_USBPHY1_BASE + HW_USBPHY_CTRL_CLR);
+
+		//enable LAN
+		val = __raw_readl(REGS_ENET_BASE + HW_ENET_MAC_ECR);
+		val &= ~(BM_ENET_MAC_ECR_SLEEP);
+		__raw_writel(val, REGS_ENET_BASE + HW_ENET_MAC_ECR);
+
+#if defined CONFIG_MECT_VAL01
+		gpio_direction_output(MXS_PIN_TO_GPIO(PINID_SSP1_DATA3), 0);
+
+#elif defined CONFIG_MECT_ELE01 || defined CONFIG_MECT_TPAC1006 || defined CONFIG_MECT_U295 || defined CONFIG_MECT_TPAC1006_640x480
+		gpio_direction_output(MXS_PIN_TO_GPIO(PINID_SSP1_DATA3), 0);
+
+#else
+		gpio_direction_output(MXS_PIN_TO_GPIO(PINID_SSP1_DATA3), 0);
+#endif
+
+		//enable LCD
+		//__raw_writel(BM_LCDIF_CTRL_CLKGATE, REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+
+		
+		__raw_writel(BF_PWM_ACTIVEn_INACTIVE(0) |
+			     BF_PWM_ACTIVEn_ACTIVE(0),
+			     REGS_PWM_BASE + HW_PWM_ACTIVEn(2));
+
+		__raw_writel(BF_PWM_PERIODn_CDIV(6) |	/* divide by 64 */
+			     BF_PWM_PERIODn_INACTIVE_STATE(2) |	/* low */
+			     BF_PWM_PERIODn_ACTIVE_STATE(3) |	/* high */
+			     BF_PWM_PERIODn_PERIOD(599),
+			     REGS_PWM_BASE + HW_PWM_PERIODn(2));
+		__raw_writel(BM_PWM_CTRL_PWM2_ENABLE, REGS_PWM_BASE + HW_PWM_CTRL_SET);
+
+	}
+
+}
+
+
+static irqreturn_t gpio_pwrfails_isr(int irq, void *dev_id)
+{
+	struct gpio_pwrfail_data *plat_data = dev_id;
+	struct gpio_pwrfail *pwrfail = plat_data->pwrfail;
+	
+	int val;
+
+#ifdef PWRFAIL_DEBUG
+	printk("PWRFAIL_DEBUG PWRFAIL event INTERRUPT %s\n", __func__);
+#endif
+
+#ifdef PWRFAIL_DEBUG
+	//spengo il led di segnalazione T4
+	gpio_set_value(MXS_PIN_TO_GPIO(PINID_SSP2_MOSI), 0);
+
+#endif
+	BUG_ON(irq != gpio_to_irq(pwrfail->gpio));
+
+	schedule_work(&plat_data->work);
+
+	return IRQ_HANDLED;
+}
+
+
+static int __devinit gpio_pwrfail_setup(struct platform_device *pdev,
+					 struct gpio_pwrfail_data *plat_data,
+					 struct gpio_pwrfail *pwrfail)
+{
+
+	char *desc = pwrfail->desc ? pwrfail->desc : "gpio_pwrfails";
+	struct device *dev = &pdev->dev;
+	unsigned long irqflags;
+	int irq, error;
+
+#ifdef PWRFAIL_DEBUG
+	printk("PWRFAIL_DEBUG %s: ENTER\n", __func__);
+	//led di segnalazione per debug
+	gpio_direction_output(MXS_PIN_TO_GPIO(PINID_SSP2_MOSI), 0);
+#endif
+
+	INIT_WORK(&plat_data->work, gpio_pwrfail_work_func);
+	error = gpio_request(pwrfail->gpio, desc);
+	if (error < 0) {
+		dev_err(dev, "failed to request GPIO %d, error %d\n",
+			pwrfail->gpio, error);
+		goto fail2;
+	}
+
+	error = gpio_direction_input(pwrfail->gpio);
+	if (error < 0) {
+		dev_err(dev, "failed to configure"
+			" direction for GPIO %d, error %d\n",
+			pwrfail->gpio, error);
+		goto fail3;
+	}
+
+	irq = gpio_to_irq(pwrfail->gpio);
+	if (irq < 0) {
+		error = irq;
+		dev_err(dev, "Unable to get irq number for GPIO %d, error %d\n",
+			pwrfail->gpio, error);
+		goto fail3;
+	}
+
+         //irqflags =  IRQF_TRIGGER_RISING; /* | IRQF_TRIGGER_FALLING; */
+	irqflags =  IRQF_TRIGGER_RISING;
+	
+	/*
+	 * If platform has specified that the button can be disabled,
+	 * we don't want it to share the interrupt line.
+	 */
+	if (!pwrfail->can_disable)
+		irqflags |= IRQF_SHARED;
+
+	error = request_irq(irq, gpio_pwrfails_isr, irqflags, desc, plat_data);
+	if (error) {
+		dev_err(dev, "Unable to claim irq %d; error %d\n",
+			irq, error);
+		goto fail3;
+	}
+#ifdef PWRFAIL_DEBUG
+	printk("PWRFAIL_DEBUG %s: SETUP REGULAR END\n", __func__);
+#endif
+	return 0;
+
+fail3:
+#ifdef PWRFAIL_DEBUG
+	printk("PWRFAIL_DEBUG %s: EXIT FAIL3\n", __func__);
+#endif
+	gpio_free(pwrfail->gpio);
+fail2:
+#ifdef PWRFAIL_DEBUG
+	printk("PWRFAIL_DEBUG %s: EXIT FAIL2\n", __func__);
+#endif
+	return error;
+}
+
+
+static int __devinit gpio_pwrfails_probe(struct platform_device *pdev)
+{
+
+	struct gpio_pwrfail_platform_data *pdata = pdev->dev.platform_data;
+	struct gpio_pwrfail_drvdata *ddata;
+	struct device *dev = &pdev->dev;
+	int i, error;
+	
+#ifdef PWRFAIL_DEBUG
+	printk("PWRFAIL_DEBUG %s: ENTER\n", __func__);
+#endif	
+
+	ddata = kzalloc(sizeof(struct gpio_pwrfail_drvdata) +
+			pdata->npwrfails * sizeof(struct gpio_pwrfail_data),
+			GFP_KERNEL);
+
+	if (!ddata ) {
+		dev_err(dev, "failed to allocate state\n");
+		error = -ENOMEM;
+		goto fail1;
+	}
+
+	ddata->n_pwrfails = pdata->npwrfails;
+	platform_set_drvdata(pdev, ddata);
+
+	for (i = 0; i < pdata->npwrfails; i++) {
+		struct gpio_pwrfail *pwrfail = &pdata->pwrfails[i];
+		struct gpio_pwrfail_data *plat_data = &ddata->data[i];
+
+		plat_data->pwrfail = pwrfail;
+
+		error = gpio_pwrfail_setup(pdev, plat_data, pwrfail);
+		if (error)
+			goto fail2;
+
+	}
+	//add code to setup  and manage signalconfpid
+#ifdef PWRFAIL_DEBUG
+
+	printk("PWRFAIL_DEBUG %s: PROBE REGULAR END\n", __func__);
+#endif
+	return 0;
+
+ fail2:
+#ifdef PWRFAIL_DEBUG
+	printk("PWRFAIL_DEBUG %s: EXIT FAIL2\n", __func__);
+#endif
+	while (--i >= 0) {
+		free_irq(gpio_to_irq(pdata->pwrfails[i].gpio), &ddata->data[i]);
+		cancel_work_sync(&ddata->data[i].work);
+		gpio_free(pdata->pwrfails[i].gpio);
+	}
+	platform_set_drvdata(pdev, NULL);
+ fail1:
+#ifdef PWRFAIL_DEBUG
+	printk("PWRFAIL_DEBUG %s: EXIT FAIL1\n", __func__);
+#endif
+	kfree(ddata);
+
+	return error;
+}
+
+
+
+static int __devexit gpio_pwrfails_remove(struct platform_device *pdev)
+{
+	struct gpio_pwrfail_platform_data *pdata = pdev->dev.platform_data;
+	struct gpio_pwrfail_drvdata *ddata = platform_get_drvdata(pdev);
+	
+	int i;
+
+	for (i = 0; i < pdata->npwrfails; i++) {
+		int irq = gpio_to_irq(pdata->pwrfails[i].gpio);
+		free_irq(irq, &ddata->data[i]);
+		cancel_work_sync(&ddata->data[i].work);
+		gpio_free(pdata->pwrfails[i].gpio);
+	}
+
+	return 0;
+}
+
+
+static struct platform_driver gpio_pwrfails_device_driver = {
+	.probe		= gpio_pwrfails_probe,
+	.remove		= __devexit_p(gpio_pwrfails_remove),
+	.driver		= {
+		.name	= "gpio-pwrfails",
+		.owner	= THIS_MODULE,
+	}
+};
+
+static int __init gpio_pwrfails_init(void)
+{
+	int ret;	
+	ret =  platform_driver_register(&gpio_pwrfails_device_driver);
+#ifdef PWRFAIL_SIGNAL
+	/* only root can write to this file (no read) */
+	file = debugfs_create_file("signalconfpid", 0200, NULL, NULL, &my_fops);
+	pid = 0;
+#endif
+	return ret;
+}
+
+static void __exit gpio_pwrfails_exit(void)
+{
+	platform_driver_unregister(&gpio_pwrfails_device_driver);
+#ifdef PWRFAIL_SIGNAL
+	if (file)
+		debugfs_remove(file);
+#endif
+}
+
+module_init(gpio_pwrfails_init);
+module_exit(gpio_pwrfails_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Monica Donno <mdonno@mect.it>");
+MODULE_DESCRIPTION("GPIO based power fail management driver");
+MODULE_ALIAS("platform:gpio-pwrfails");
+
+
diff --exclude CVS --exclude .git -uNr linux-2.6.35.3/drivers/power/mxs/ddi_power_battery.c linux-2.6.35.3.modified/drivers/power/mxs/ddi_power_battery.c
--- linux-2.6.35.3/drivers/power/mxs/ddi_power_battery.c	2013-05-06 13:04:09.174866803 +0200
+++ linux-2.6.35.3.modified/drivers/power/mxs/ddi_power_battery.c	2013-04-17 12:03:03.225012044 +0200
@@ -36,6 +36,20 @@
 #include <mach/lradc.h>
 #include "ddi_bc_internal.h"
 
+#if 0
+#include "mx28evk.h" /*periperal shutdown */
+#include <mach/regs-lcdif.h>
+#include <mach/regs-pwm.h>
+#include <mach/mx28.h>
+#endif
+
+#include  <mach/../../regs-clkctrl.h>
+#include <mach/lcdif.h>
+#include <mach/regs-lcdif.h>
+#include <mach/regs-pwm.h>
+#include <mach/regs-ssp.h>
+#include <mach/regs-rtc.h>
+
 /* brief Base voltage to start battery calculations for LiIon */
 #define BATT_BRWNOUT_LIION_BASE_MV 2800
 /* brief Constant to help with determining whether to round up or */
@@ -95,6 +109,9 @@
 #define BM_POWER_STS_VBUSVALID BM_POWER_STS_VBUSVALID0
 #endif
 
+
+
+
 /* Globals & Variables */
 
 
@@ -165,6 +182,9 @@
 
 void ddi_power_Enable5vDetection(void)
 {
+#ifdef BATT_DBG
+	printk("ddi_power_Enable5vDetection\n");
+#endif
 	u32 val;
 	/* Disable hardware power down when 5V is inserted or removed */
 	__raw_writel(BM_POWER_5VCTRL_PWDN_5VBRNOUT,
@@ -213,11 +233,17 @@
 		/* Check VBUSVALID for 5V present */
 		__raw_writel(BM_POWER_CTRL_ENIRQ_VBUS_VALID,
 				REGS_POWER_BASE + HW_POWER_CTRL_SET);
+#ifdef BATT_DBG
+	printk("ddi_power_Enable5vDetection--DDI_POWER_5V_VBUSVALID\n");
+#endif
 		break;
 	case DDI_POWER_5V_VDD5V_GT_VDDIO:
 		/* Check VDD5V_GT_VDDIO for 5V present */
 		__raw_writel(BM_POWER_CTRL_ENIRQ_VDD5V_GT_VDDIO,
 				REGS_POWER_BASE + HW_POWER_CTRL_SET);
+#ifdef BATT_DBG
+	printk("ddi_power_Enable5vDetection--DDI_POWER_5V_VDD5V_GT_VDDIO\n");
+#endif
 		break;
 	}
 }
@@ -229,6 +255,9 @@
  */
 void ddi_power_enable_5v_to_battery_handoff(void)
 {
+#ifdef BATT_DBG
+	printk("ddi_power_enable_5v_to_battery_handoff\n");
+#endif
 	/* Clear vbusvalid interrupt flag */
 	__raw_writel(BM_POWER_CTRL_VBUSVALID_IRQ,
 				REGS_POWER_BASE + HW_POWER_CTRL_CLR);
@@ -248,6 +277,309 @@
 #endif
 }
 
+
+/*
+ * This function will handle all transitions necesarry to power down 
+ * the chip peripherals unneeded when a 5v disconnection is detected.
+ * 
+ */
+
+void ddi_power_execute_peripheral_shutdown(void)
+{
+	int i;
+	int val;
+
+	//printk("spengo...\n");
+
+#if 1
+#define REGS_ENET_BASE IO_ADDRESS(ENET_PHYS_ADDR)	
+#define HW_ENET_MAC_ECR	(0x00000024)
+#define BM_ENET_MAC_ECR_SLEEP	(0x00000008)
+
+#define REGS_USBPHY0_BASE	IO_ADDRESS(USBPHY0_PHYS_ADDR)
+#define REGS_USBPHY1_BASE	IO_ADDRESS(USBPHY1_PHYS_ADDR)
+#define HW_USBPHY_CTRL_SET	(0x00000034)
+#define BM_USBPHY_CTRL_CLKGATE	0x40000000
+
+#define REGS_CAN0_BASE	IO_ADDRESS(CAN0_PHYS_ADDR)
+#define REGS_CAN1_BASE	IO_ADDRESS(CAN1_PHYS_ADDR)
+#define CAN_HW_REG_MCR		0x00
+#define __MCR_MDIS		(1 << 31)
+
+#define REGS_SSP0_BASE	IO_ADDRESS(SSP0_PHYS_ADDR)
+#define REGS_SSP1_BASE	IO_ADDRESS(SSP1_PHYS_ADDR)
+#define REGS_SSP2_BASE	IO_ADDRESS(SSP2_PHYS_ADDR)
+#define REGS_SSP3_BASE	IO_ADDRESS(SSP3_PHYS_ADDR)
+#define REGS_PERFMON_BASE IO_ADDRESS(PERFMON_PHYS_ADDR)
+#define HW_PERFMON_CTRL_SET (0x00000004)
+#define BM_PERFMON_CTRL_CLKGATE 0x40000000
+#define BM_PERFMON_CTRL_SFTRST 0x80000000
+
+#define RTC_BASE_ADDR IO_ADDRESS(RTC_PHYS_ADDR)	
+
+#define AUART0_BASE_ADDR IO_ADDRESS(AUART0_PHYS_ADDR)
+#define AUART1_BASE_ADDR IO_ADDRESS(AUART1_PHYS_ADDR)
+#define AUART2_BASE_ADDR IO_ADDRESS(AUART2_PHYS_ADDR)
+#define AUART3_BASE_ADDR IO_ADDRESS(AUART3_PHYS_ADDR)
+#define AUART4_BASE_ADDR IO_ADDRESS(AUART4_PHYS_ADDR)
+#define HW_UARTAPP_CTRL0_SET	(0x00000004)
+#define BM_UARTAPP_CTRL0_CLKGATE	0x40000000
+#define BM_UARTAPP_CTRL0_SFTRST	0x80000000
+
+#define PXP_BASE_ADDR 	IO_ADDRESS(PXP_PHYS_ADDR)
+#define HW_PXP_CTRL_SET	(0x00000004)
+#define BM_PXP_CTRL_CLKGATE	0x40000000
+#define BM_PXP_CTRL_SFTRST	0x80000000
+
+#define SAIF0_BASE_ADDR IO_ADDRESS(SAIF0_PHYS_ADDR)
+#define SAIF1_BASE_ADDR IO_ADDRESS(SAIF0_PHYS_ADDR)
+#define HW_SAIF_CTRL_SET	(0x00000004)
+#define BM_SAIF_CTRL_CLKGATE	0x40000000
+#define BM_SAIF_CTRL_SFTRST	0x80000000
+
+#define SPDIF_BASE_ADDR IO_ADDRESS(SPDIF_PHYS_ADDR)
+#define HW_SPDIF_CTRL_SET	(0x00000004)
+#define BM_SPDIF_CTRL_CLKGATE	0x40000000
+#define BM_SPDIF_CTRL_SFTRST	0x80000000
+
+#define HSADC_BASE_ADDR IO_ADDRESS(HSADC_PHYS_ADDR)
+#define HW_HSADC_CTRL0_SET	(0x00000004)
+#define BM_HSADC_CTRL0_CLKGATE	0x40000000
+#define BM_HSADC_CTRL0_SFTRST	0x80000000
+#define HW_HSADC_CTRL2_SET	(0x00000024)
+#define BM_HSADC_CTRL2_POWERDOWN 0x00002000
+	//ethernet 
+	val = __raw_readl(REGS_ENET_BASE + HW_ENET_MAC_ECR);
+	val &= ~(BM_ENET_MAC_ECR_SLEEP);
+	__raw_writel(val, REGS_ENET_BASE + HW_ENET_MAC_ECR);
+
+
+	//stop LCDIF
+	__raw_writel(BM_LCDIF_CTRL_CLKGATE,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_SET);
+	__raw_writel(BM_LCDIF_CTRL_RUN, REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+	__raw_writel(BM_LCDIF_CTRL_LCDIF_MASTER,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+
+
+	//stop bcklight
+	__raw_writel(BF_PWM_ACTIVEn_INACTIVE(0) |
+		     BF_PWM_ACTIVEn_ACTIVE(0),
+		     REGS_PWM_BASE + HW_PWM_ACTIVEn(2));
+	__raw_writel(BF_PWM_PERIODn_CDIV(6) |	/* divide by 64 */
+		     BF_PWM_PERIODn_INACTIVE_STATE(2) |	/* low */
+		     BF_PWM_PERIODn_ACTIVE_STATE(3) |	/* high */
+		     BF_PWM_PERIODn_PERIOD(599),
+		     REGS_PWM_BASE + HW_PWM_PERIODn(2));
+	__raw_writel(BM_PWM_CTRL_PWM2_ENABLE, REGS_PWM_BASE + HW_PWM_CTRL_CLR);
+
+	//usb
+	__raw_writel(BM_USBPHY_CTRL_CLKGATE, REGS_USBPHY0_BASE + HW_USBPHY_CTRL_SET);
+	__raw_writel(BM_USBPHY_CTRL_CLKGATE, REGS_USBPHY1_BASE + HW_USBPHY_CTRL_SET);
+
+	//can
+	val = __raw_readl(REGS_CAN0_BASE + CAN_HW_REG_MCR);
+	__raw_writel(val | __MCR_MDIS, REGS_CAN0_BASE + CAN_HW_REG_MCR);
+	val = __raw_readl(REGS_CAN1_BASE + CAN_HW_REG_MCR);
+	__raw_writel(val | __MCR_MDIS, REGS_CAN1_BASE + CAN_HW_REG_MCR);
+#endif
+#if 0
+	//ssp
+	//__raw_writel(BM_SSP_CTRL0_CLKGATE | BM_SSP_CTRL0_SFTRST, REGS_SSP0_BASE + HW_SSP_CTRL0_SET);
+	//__raw_writel(BM_SSP_CTRL0_CLKGATE | BM_SSP_CTRL0_SFTRST, REGS_SSP1_BASE + HW_SSP_CTRL0_SET);
+	//__raw_writel(BM_SSP_CTRL0_CLKGATE | BM_SSP_CTRL0_SFTRST, REGS_SSP2_BASE + HW_SSP_CTRL0_SET);
+	//__raw_writel(BM_SSP_CTRL0_CLKGATE | BM_SSP_CTRL0_SFTRST, REGS_SSP3_BASE + HW_SSP_CTRL0_SET);
+
+	__raw_writel(BM_SSP_CTRL0_CLKGATE, REGS_SSP0_BASE + HW_SSP_CTRL0_SET);
+	__raw_writel(BM_SSP_CTRL0_CLKGATE, REGS_SSP1_BASE + HW_SSP_CTRL0_SET);
+	__raw_writel(BM_SSP_CTRL0_CLKGATE, REGS_SSP2_BASE + HW_SSP_CTRL0_SET);
+	__raw_writel(BM_SSP_CTRL0_CLKGATE, REGS_SSP3_BASE + HW_SSP_CTRL0_SET);
+
+	//perfmon
+	//__raw_writel(BM_PERFMON_CTRL_CLKGATE | BM_PERFMON_CTRL_SFTRST, REGS_PERFMON_BASE + HW_PERFMON_CTRL_SET);
+	__raw_writel(BM_PERFMON_CTRL_CLKGATE, REGS_PERFMON_BASE + HW_PERFMON_CTRL_SET);
+
+	//rtc
+	//__raw_writel(BM_RTC_CTRL_CLKGATE | BM_RTC_CTRL_SFTRST, RTC_BASE_ADDR + HW_RTC_CTRL_SET);
+	__raw_writel(BM_RTC_CTRL_CLKGATE, RTC_BASE_ADDR + HW_RTC_CTRL_SET);
+
+	//appuart
+	//__raw_writel(BM_UARTAPP_CTRL0_CLKGATE | BM_UARTAPP_CTRL0_SFTRST, AUART0_BASE_ADDR + HW_UARTAPP_CTRL0_SET);
+	//__raw_writel(BM_UARTAPP_CTRL0_CLKGATE | BM_UARTAPP_CTRL0_SFTRST, AUART1_BASE_ADDR + HW_UARTAPP_CTRL0_SET);
+	//__raw_writel(BM_UARTAPP_CTRL0_CLKGATE | BM_UARTAPP_CTRL0_SFTRST, AUART2_BASE_ADDR + HW_UARTAPP_CTRL0_SET);
+	//__raw_writel(BM_UARTAPP_CTRL0_CLKGATE | BM_UARTAPP_CTRL0_SFTRST, AUART3_BASE_ADDR + HW_UARTAPP_CTRL0_SET);
+	//__raw_writel(BM_UARTAPP_CTRL0_CLKGATE | BM_UARTAPP_CTRL0_SFTRST, AUART4_BASE_ADDR + HW_UARTAPP_CTRL0_SET);
+
+	__raw_writel(BM_UARTAPP_CTRL0_CLKGATE, AUART0_BASE_ADDR + HW_UARTAPP_CTRL0_SET);
+	__raw_writel(BM_UARTAPP_CTRL0_CLKGATE, AUART1_BASE_ADDR + HW_UARTAPP_CTRL0_SET);
+	__raw_writel(BM_UARTAPP_CTRL0_CLKGATE, AUART2_BASE_ADDR + HW_UARTAPP_CTRL0_SET);
+	__raw_writel(BM_UARTAPP_CTRL0_CLKGATE, AUART3_BASE_ADDR + HW_UARTAPP_CTRL0_SET);
+	__raw_writel(BM_UARTAPP_CTRL0_CLKGATE, AUART4_BASE_ADDR + HW_UARTAPP_CTRL0_SET);
+
+	//pxp
+	//__raw_writel(BM_PXP_CTRL_CLKGATE | BM_PXP_CTRL_SFTRST, PXP_BASE_ADDR + HW_PXP_CTRL_SET);
+	__raw_writel(BM_PXP_CTRL_CLKGATE, PXP_BASE_ADDR + HW_PXP_CTRL_SET);
+
+	//saif
+	//__raw_writel(BM_SAIF_CTRL_CLKGATE | BM_SAIF_CTRL_SFTRST, SAIF0_BASE_ADDR + HW_SAIF_CTRL_SET);
+	//__raw_writel(BM_SAIF_CTRL_CLKGATE | BM_SAIF_CTRL_SFTRST, SAIF1_BASE_ADDR + HW_SAIF_CTRL_SET);
+	__raw_writel(BM_SAIF_CTRL_CLKGATE, SAIF0_BASE_ADDR + HW_SAIF_CTRL_SET);
+	__raw_writel(BM_SAIF_CTRL_CLKGATE, SAIF1_BASE_ADDR + HW_SAIF_CTRL_SET);
+
+	//spdif
+	//__raw_writel(BM_SPDIF_CTRL_CLKGATE | BM_SPDIF_CTRL_SFTRST, SPDIF_BASE_ADDR + HW_SPDIF_CTRL_SET);
+	__raw_writel(BM_SPDIF_CTRL_CLKGATE, SPDIF_BASE_ADDR + HW_SPDIF_CTRL_SET);
+	
+	//hsadc
+	//__raw_writel(BM_HSADC_CTRL0_CLKGATE | BM_HSADC_CTRL0_SFTRST, HSADC_BASE_ADDR + HW_HSADC_CTRL0_SET);
+	__raw_writel(BM_HSADC_CTRL0_CLKGATE, HSADC_BASE_ADDR + HW_HSADC_CTRL0_SET);
+	__raw_writel(BM_HSADC_CTRL2_POWERDOWN, HSADC_BASE_ADDR + HW_HSADC_CTRL2_SET);
+
+#endif
+
+//shutdown directly the clocks 
+#if 0
+#define CLKCTRL_BASE_ADDR IO_ADDRESS(CLKCTRL_PHYS_ADDR)
+
+	//If set to 1, CLK_DIS_LCDIF is gated off
+	for (i = 10000; i; i--){
+		val = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_DIS_LCDIF);
+		if (!(val & (1 << 29)))
+		{	val |= BM_CLKCTRL_DIS_LCDIF_CLKGATE;
+			__raw_writel(val, CLKCTRL_BASE_ADDR + HW_CLKCTRL_DIS_LCDIF);
+			break;
+		}
+	}
+	if (!i) {
+		printk("couldn't set up CLK_DIS_LCDIF\n");
+	}
+
+	// if 0 PLL outputs for USB0 PHY are powered down.
+	__raw_writel(BM_CLKCTRL_PLL0CTRL0_EN_USB_CLKS, CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLL0CTRL0_CLR);
+
+	// if 0 PLL outputs for USB1 PHY are powered down.
+	__raw_writel(BM_CLKCTRL_PLL1CTRL0_EN_USB_CLKS, CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLL1CTRL0_CLR);
+
+	//If set to 1, the ENET PLL clock is off 
+	__raw_writel(BM_CLKCTRL_PLL2CTRL0_CLKGATE, CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLL2CTRL0_SET);
+
+	//If set to 1, fixed 24-MHz clock for the UART, CLK_UART, is gated off.
+	__raw_writel(BM_CLKCTRL_XTAL_UART_CLK_GATE, CLKCTRL_BASE_ADDR + HW_CLKCTRL_XTAL_SET);
+	//If set to 1, fixed 24-MHz clock for the PWM, CLK_PWM24M, is gated off.
+	__raw_writel(BM_CLKCTRL_XTAL_PWM_CLK24M_GATE, CLKCTRL_BASE_ADDR + HW_CLKCTRL_XTAL_SET);
+
+//If set to 1, CLK_SSP0 is gated off
+	
+	for (i = 10000; i; i--){
+		val = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP0);
+		if (!(val & (1 << 29)))
+		{	val |= BM_CLKCTRL_SSP0_CLKGATE;
+			__raw_writel(val, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP0);
+			break;
+		}
+	}
+	if (!i) {
+		printk("couldn't set up HW_CLKCTRL_SSP0\n");
+	}
+//If set to 1, CLK_SSP1 is gated off
+	for (i = 10000; i; i--){
+		val = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP1);
+		if (!(val & (1 << 29)))
+		{	val |= BM_CLKCTRL_SSP1_CLKGATE;
+			__raw_writel(val, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP1);
+			break;
+		}
+	}
+	if (!i) {
+		printk("couldn't set up HW_CLKCTRL_SSP1\n");
+	}
+//If set to 1, CLK_SSP2 is gated off
+	for (i = 10000; i; i--){
+		val = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP2);
+		if (!(val & (1 << 29)))
+		{	val |= BM_CLKCTRL_SSP2_CLKGATE;
+			__raw_writel(val, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP2);
+			break;
+		}
+	}
+	if (!i) {
+		printk("couldn't set up HW_CLKCTRL_SSP2\n");
+	}
+//If set to 1, CLK_SSP3 is gated off
+	for (i = 10000; i; i--){
+		val = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP3);
+		if (!(val & (1 << 29)))
+		{	val |= BM_CLKCTRL_SSP3_CLKGATE;
+			__raw_writel(val, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP3);
+			break;
+		}
+	}
+	if (!i) {
+		printk("couldn't set up HW_CLKCTRL_SSP3\n");
+	}
+
+	//If set to 1, CLK_PCMSPDIF is gated off.
+	val = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SPDIF);
+	val |= BM_CLKCTRL_SPDIF_CLKGATE;
+	__raw_writel(val, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SPDIF);
+
+//If set to 1, CLK_SAIF0 is gated off
+	for (i = 10000; i; i--){
+		val = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF0);
+		if (!(val & (1 << 29)))
+		{	val |= BM_CLKCTRL_SAIF0_CLKGATE;
+			__raw_writel(val, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF0);
+			break;
+		}
+	}
+	if (!i) {
+		printk("couldn't set up CLK_SAIF0\n");
+	}
+//If set to 1, CLK_SAIF1 is gated off
+	for (i = 10000; i; i--){
+		val = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF1);
+		if (!(val & (1 << 29)))
+		{	val |= BM_CLKCTRL_SAIF1_CLKGATE;
+			__raw_writel(val, CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF1);
+			break;
+		}
+	}
+	if (!i) {
+		printk("couldn't set up CLK_SAIF1\n");
+	}
+
+
+ //If set to 1, CLK_ETM is gated off
+	for (i = 10000; i; i--){
+		val = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_ETM);
+		if (!(val & (1 << 29)))
+		{	val |= BM_CLKCTRL_ETM_CLKGATE;
+			__raw_writel(val, CLKCTRL_BASE_ADDR + HW_CLKCTRL_ETM);
+			break;
+		}
+	}
+	if (!i) {
+		printk("couldn't set up CLK_DIS_LCDIF\n");
+	}
+
+//if set to 1, put Ethernet block in sleep mode
+	val = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_ENET);
+	val |= BM_CLKCTRL_ENET_SLEEP;
+	__raw_writel(val, CLKCTRL_BASE_ADDR + HW_CLKCTRL_ENET);
+
+//if set to the FLEXCAN0 and FLEXCAN1 will be stopped and all clock to the modules are gated off
+	val = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FLEXCAN);
+	val |= (BM_CLKCTRL_FLEXCAN_STOP_CAN0 |BM_CLKCTRL_FLEXCAN_STOP_CAN1);
+	__raw_writel(val, CLKCTRL_BASE_ADDR + HW_CLKCTRL_FLEXCAN);
+
+// If set to 1, the IO0 fractional divider clock
+	__raw_writel(BM_CLKCTRL_FRAC0_CLKGATEIO0, CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0_SET);
+
+// If set to 1, the HSADC fractional divider clock and  the PIX fractional divider clock are off 
+	__raw_writel(BM_CLKCTRL_FRAC1_CLKGATEHSADC | BM_CLKCTRL_FRAC1_CLKGATEPIX, CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC1_SET);
+#endif
+	printk(" !\n");
+}
 /*
  * This function will handle all the power rail transitions necesarry to power
  * the chip from the battery when it was previously powered from the 5V power
@@ -257,6 +589,9 @@
 {
 	int val;
 #ifdef VDD4P2_ENABLED
+#ifdef BATT_DBG
+	printk("b_hoff\n");
+#endif
 	val = __raw_readl(REGS_POWER_BASE + HW_POWER_DCDC4P2);
 	val &= ~(BM_POWER_DCDC4P2_ENABLE_DCDC | BM_POWER_DCDC4P2_ENABLE_4P2);
 	__raw_writel(val, REGS_POWER_BASE + HW_POWER_DCDC4P2);
@@ -277,49 +612,98 @@
 
 	/* For LiIon battery, we will use the DCDC to power VDDD. */
 	/* Use LinReg offset for DCDC mode. */
-	__raw_writel(BF_POWER_VDDDCTRL_LINREG_OFFSET(LINREG_OFFSET_STEP_BELOW),
-				HW_POWER_BASE + HW_POWER_VDDDCTRL_SET);
+
+
+	/*__raw_writel(BF_POWER_VDDDCTRL_LINREG_OFFSET(LINREG_OFFSET_STEP_BELOW),
+				REGS_POWER_BASE + HW_POWER_VDDDCTRL_SET); */
+
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDDCTRL);
+	val |= BF_POWER_VDDDCTRL_LINREG_OFFSET(LINREG_OFFSET_STEP_BELOW);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDDCTRL);
+
 	/* Turn on the VDDD DCDC output and turn off the VDDD LinReg output. */
-	__raw_writel(BM_POWER_VDDDCTRL_DISABLE_FET,
-				HW_POWER_BASE + HW_POWER_VDDDCTRL_CLR);
+	/*__raw_writel(BM_POWER_VDDDCTRL_DISABLE_FET,
+				REGS_POWER_BASE + HW_POWER_VDDDCTRL_CLR); */
+
+	/* __raw_writel(BM_POWER_VDDDCTRL_ENABLE_LINREG,
+				REGS_POWER_BASE + HW_POWER_VDDDCTRL_CLR); */
+
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDDCTRL);
+	val &= ~(BM_POWER_VDDDCTRL_DISABLE_FET);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDDCTRL);
+
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDDCTRL);
+	val &= ~(BM_POWER_VDDDCTRL_ENABLE_LINREG);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDDCTRL);
+
 
-	__raw_writel(BM_POWER_VDDDCTRL_ENABLE_LINREG,
-				HW_POWER_BASE + HW_POWER_VDDDCTRL_CLR);
 	/* Make sure stepping is enabled when using DCDC. */
-	__raw_writel(BM_POWER_VDDDCTRL_DISABLE_STEPPING,
-				HW_POWER_BASE + HW_POWER_VDDDCTRL_CLR);
+	/*__raw_writel(BM_POWER_VDDDCTRL_DISABLE_STEPPING,
+				REGS_POWER_BASE + HW_POWER_VDDDCTRL_CLR); */
+
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDDCTRL);
+	val &= ~(BM_POWER_VDDDCTRL_DISABLE_STEPPING);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDDCTRL);
 
 	/* Power VDDA and VDDIO from the DCDC. */
 
 	/* Use LinReg offset for DCDC mode. */
-	__raw_writel(BF_POWER_VDDACTRL_LINREG_OFFSET(LINREG_OFFSET_STEP_BELOW),
-				HW_POWER_BASE + HW_POWER_VDDACTRL_SET);
+	/* __raw_writel(BF_POWER_VDDACTRL_LINREG_OFFSET(LINREG_OFFSET_STEP_BELOW),
+				REGS_POWER_BASE + HW_POWER_VDDACTRL_SET); */
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDACTRL);
+	val |= BF_POWER_VDDACTRL_LINREG_OFFSET(LINREG_OFFSET_STEP_BELOW);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDACTRL);
+
 	/* Turn on the VDDA DCDC converter output and turn off LinReg output. */
-	__raw_writel(BM_POWER_VDDACTRL_DISABLE_FET,
-				HW_POWER_BASE + HW_POWER_VDDACTRL_CLR);
+	/* __raw_writel(BM_POWER_VDDACTRL_DISABLE_FET,
+				REGS_POWER_BASE + HW_POWER_VDDACTRL_CLR);
 	__raw_writel(BM_POWER_VDDACTRL_ENABLE_LINREG,
-				HW_POWER_BASE + HW_POWER_VDDACTRL_CLR);
+				REGS_POWER_BASE + HW_POWER_VDDACTRL_CLR); */
+
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDACTRL);
+	val &= ~(BM_POWER_VDDACTRL_DISABLE_FET);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDACTRL);
+
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDACTRL);
+	val &= ~(BM_POWER_VDDACTRL_ENABLE_LINREG);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDACTRL);
 
 	/* Make sure stepping is enabled when using DCDC. */
-	__raw_writel(BM_POWER_VDDACTRL_DISABLE_STEPPING,
-				HW_POWER_BASE + HW_POWER_VDDACTRL_CLR);
+	/* __raw_writel(BM_POWER_VDDACTRL_DISABLE_STEPPING,
+				REGS_POWER_BASE + HW_POWER_VDDACTRL_CLR); */
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDACTRL);
+	val &= ~(BM_POWER_VDDACTRL_DISABLE_STEPPING);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDACTRL);
 
 	/* Use LinReg offset for DCDC mode. */
-	__raw_writel(BF_POWER_VDDIOCTRL_LINREG_OFFSET(
+	/*__raw_writel(BF_POWER_VDDIOCTRL_LINREG_OFFSET(
 					LINREG_OFFSET_STEP_BELOW
 						),
-				HW_POWER_BASE + HW_POWER_VDDIOCTRL_SET);
+				REGS_POWER_BASE + HW_POWER_VDDIOCTRL_SET); */
+
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
+	val |= BF_POWER_VDDIOCTRL_LINREG_OFFSET(LINREG_OFFSET_STEP_BELOW);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
 
 	/* Turn on the VDDIO DCDC output and turn on the LinReg output.*/
-	__raw_writel(BM_POWER_VDDIOCTRL_DISABLE_FET,
-				HW_POWER_BASE + HW_POWER_VDDIOCTRL_CLR);
+	/*__raw_writel(BM_POWER_VDDIOCTRL_DISABLE_FET,
+				REGS_POWER_BASE + HW_POWER_VDDIOCTRL_CLR); */
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
+	val &= ~(BM_POWER_VDDIOCTRL_DISABLE_FET);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
+
 
 	__raw_writel(BM_POWER_5VCTRL_ILIMIT_EQ_ZERO,
-				HW_POWER_BASE + HW_POWER_5VCTRL_CLR_CLR);
+				REGS_POWER_BASE + HW_POWER_5VCTRL_CLR);
 
 	/* Make sure stepping is enabled when using DCDC. */
-	__raw_writel(BM_POWER_VDDIOCTRL_DISABLE_STEPPING,
-				HW_POWER_BASE + HW_POWER_VDDIOCTRL_CLR);
+	/* __raw_writel(BM_POWER_VDDIOCTRL_DISABLE_STEPPING,
+				REGS_POWER_BASE + HW_POWER_VDDIOCTRL_CLR); */
+
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
+	val &= ~(BM_POWER_VDDIOCTRL_DISABLE_STEPPING);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
+
 #endif
 
 }
@@ -333,6 +717,9 @@
  */
 void ddi_power_enable_battery_to_5v_handoff(void)
 {
+#ifdef BATT_DBG
+	printk("ddi_power_enable_battery_to_5v_handoff\n");
+#endif
 	/* Clear vbusvalid interrupt flag */
 	__raw_writel(BM_POWER_CTRL_VBUSVALID_IRQ,
 				REGS_POWER_BASE + HW_POWER_CTRL_CLR);
@@ -365,60 +752,106 @@
 #ifdef VDD4P2_ENABLED
 	ddi_power_Enable4p2(450);
 #else
+	int val;
 	/* Disable the DCDC during 5V connections. */
 	__raw_writel(BM_POWER_5VCTRL_ENABLE_DCDC,
-				HW_POWER_BAE + HW_POWER_5VCTRL_CLR);
+				REGS_POWER_BASE + HW_POWER_5VCTRL_CLR);
 
 	/* Power the VDDD/VDDA/VDDIO rail from the linear regulator.  The DCDC */
 	/* is ready to automatically power the chip when 5V is removed. */
 	/* Use this configuration when powering from 5V */
 
 	/* Use LinReg offset for LinReg mode */
-	__raw_writel(BF_POWER_VDDDCTRL_LINREG_OFFSET(LINREG_OFFSET_STEP_BELOW),
-				HW_POWER_BAE + HW_POWER_VDDDCTRL_SET);
+	/* __raw_writel(BF_POWER_VDDDCTRL_LINREG_OFFSET(LINREG_OFFSET_STEP_BELOW),
+				REGS_POWER_BASE + HW_POWER_VDDDCTRL_SET); */
+
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDDCTRL);
+	val |= BF_POWER_VDDDCTRL_LINREG_OFFSET(LINREG_OFFSET_STEP_BELOW);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDDCTRL);
 
 	/* Turn on the VDDD LinReg and turn on the VDDD DCDC output.  The */
 	/* ENABLE_DCDC must be cleared to avoid LinReg and DCDC conflict. */
-	__raw_writel(BM_POWER_VDDDCTRL_ENABLE_LINREG,
-				HW_POWER_BAE + HW_POWER_VDDDCTRL_SET);
+	/* __raw_writel(BM_POWER_VDDDCTRL_ENABLE_LINREG,
+				REGS_POWER_BASE + HW_POWER_VDDDCTRL_SET);
 	__raw_writel(BM_POWER_VDDDCTRL_DISABLE_FET,
-				HW_POWER_BAE + HW_POWER_VDDDCTRL_CLR);
+				REGS_POWER_BASE + HW_POWER_VDDDCTRL_CLR); */
+
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDDCTRL);
+	val |= (BM_POWER_VDDDCTRL_ENABLE_LINREG);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDDCTRL);
+
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDDCTRL);
+	val &= ~(BM_POWER_VDDDCTRL_DISABLE_FET);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDDCTRL);
+
 
 	/* Make sure stepping is disabled when using linear regulators */
-	__raw_writel(BM_POWER_VDDDCTRL_DISABLE_STEPPING,
-				HW_POWER_BAE + HW_POWER_VDDDCTRL_SET);
+	/* __raw_writel(BM_POWER_VDDDCTRL_DISABLE_STEPPING,
+				REGS_POWER_BASE + HW_POWER_VDDDCTRL_SET); */
+
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDDCTRL);
+	val |= (BM_POWER_VDDDCTRL_DISABLE_STEPPING);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDDCTRL);
 
 	/* Use LinReg offset for LinReg mode */
-	__raw_writel(BM_POWER_VDDACTRL_LINREG_OFFSET(LINREG_OFFSET_STEP_BELOW),
-				HW_POWER_BAE + HW_POWER_VDDACTRL_SET);
+	/* __raw_writel(BM_POWER_VDDACTRL_LINREG_OFFSET(LINREG_OFFSET_STEP_BELOW),
+				REGS_POWER_BASE + HW_POWER_VDDACTRL_SET); */
 
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDACTRL);
+	val |= (BF_POWER_VDDACTRL_LINREG_OFFSET(LINREG_OFFSET_STEP_BELOW));
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDACTRL);
 
 	/* Turn on the VDDA LinReg output and prepare the DCDC for transfer. */
 	/* ENABLE_DCDC must be clear to avoid DCDC and LinReg conflict. */
-	stmp3xxx_set(BM_POWER_VDDACTRL_ENABLE_LINREG,
-				HW_POWER_BASE + HW_POWER_VDDACTRL_SET);
+	/* stmp3xxx_set(BM_POWER_VDDACTRL_ENABLE_LINREG,
+				REGS_POWER_BASE + HW_POWER_VDDACTRL_SET);
 	__raw_writel(BM_POWER_VDDACTRL_DISABLE_FET,
-				HW_POWER_BASE + HW_POWER_VDDACTRL_CLR);
+				REGS_POWER_BASE + HW_POWER_VDDACTRL_CLR); */
+
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDACTRL);
+	val |= (BM_POWER_VDDACTRL_ENABLE_LINREG);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDACTRL);
+
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDACTRL);
+	val &= ~(BM_POWER_VDDACTRL_DISABLE_FET);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDACTRL);
 
 	/* Make sure stepping is disabled when using linear regulators */
-	__raw_writel(BM_POWER_VDDACTRL_DISABLE_STEPPING,
-				 HW_POWER_BASE + HW_POWER_VDDACTRL_SET);
+	/* __raw_writel(BM_POWER_VDDACTRL_DISABLE_STEPPING,
+				 REGS_POWER_BASE + HW_POWER_VDDACTRL_SET); */
+
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDACTRL);
+	val |= (BM_POWER_VDDACTRL_DISABLE_STEPPING);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDACTRL);
 
 	/* Use LinReg offset for LinReg mode. */
-	__raw_writel(BF_POWER_VDDIOCTRL_LINREG_OFFSET(
+	/* __raw_writel(BF_POWER_VDDIOCTRL_LINREG_OFFSET(
 					LINREG_OFFSET_STEP_BELOW),
-				HW_POWER_BASE + HW_POWER_VDDIOCTRL_SET);
+				REGS_POWER_BASE + HW_POWER_VDDIOCTRL_SET); */
+
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
+	val |= (BF_POWER_VDDIOCTRL_LINREG_OFFSET(LINREG_OFFSET_STEP_BELOW));
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
 
 	/* Turn on the VDDIO LinReg output and prepare the VDDIO DCDC output. */
 	/* ENABLE_DCDC must be cleared to prevent DCDC and LinReg conflict. */
-	__raw_writel(BM_POWER_VDDIOCTRL_DISABLE_FET,
-				HW_POWER_BASE + HW_POWER_VDDIOCTRL_CLR);
+	/* __raw_writel(BM_POWER_VDDIOCTRL_DISABLE_FET,
+				REGS_POWER_BASE + HW_POWER_VDDIOCTRL_CLR); */
+	
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
+	val &= ~(BM_POWER_VDDIOCTRL_DISABLE_FET);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
+
 	__raw_writel(BM_POWER_5VCTRL_ILIMIT_EQ_ZERO,
 			REGS_POWER_BASE + HW_POWER_5VCTRL_CLR);
 
 	/* Make sure stepping is disabled when using DCDC. */
-	__raw_writel(BM_POWER_VDDIOCTRL_DISABLE_STEPPING,
-			REGS_POWER_BASE + HW_POWER_VDDIOCTRL_SET);
+	/* __raw_writel(BM_POWER_VDDIOCTRL_DISABLE_STEPPING,
+			REGS_POWER_BASE + HW_POWER_VDDIOCTRL_SET); */
+
+	val = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
+	val |= (BM_POWER_VDDIOCTRL_DISABLE_STEPPING);
+	__raw_writel(val, REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
 #endif
 }
 
@@ -843,6 +1276,9 @@
 	int val;
 	/* The following settings give optimal power supply capability */
 
+#ifdef BATT_DBG
+	printk("ddi_power_init_handoff\n");
+#endif
 	/* enable 5v presence detection */
 	ddi_power_Enable5vDetection();
 
@@ -888,12 +1324,18 @@
 			power driver behavior may not be reliable \n");
 		ret = 1;
 	}
+	/*if the following check is done here the battery driver will not be correctly probed. This is due to the 
+	* fact that we disabled at all booting from battery in power-prep. This code should be moved AFTER the initialization
+	* of battery level monitoring code in order to havethe bettery module loaded by the kernel
+	*/
+#if 1
 	if ((__raw_readl(REGS_POWER_BASE + HW_POWER_BATTMONITOR) &
 		BM_POWER_BATTMONITOR_BATT_VAL) == 0) {
 		ret = 1;
 		printk(KERN_INFO "WARNING : No battery connected !\r\n");
 		return ret;
 	}
+#endif
 
 	/* the following code to enable automatic battery measurement
 	 * should have already been enabled in the boot prep files.  Not
@@ -962,7 +1404,18 @@
 				break;
 #endif
 	}
-
+	/* 
+	* Check here the bettry level in order to complete correctly the probe for battery driver
+	*/
+#if 0
+	printk(KERN_INFO "WARNING : check on battery level moved !\r\n");
+	if ((__raw_readl(REGS_POWER_BASE + HW_POWER_BATTMONITOR) &
+		BM_POWER_BATTMONITOR_BATT_VAL) == 0) {
+		ret = 1;
+		printk(KERN_INFO "WARNING : No battery connected !\r\n");
+		return ret;
+	}
+#endif
 #ifndef VDD4P2_ENABLED
 	/* prepare handoff */
 	ddi_power_init_handoff();
@@ -1444,10 +1897,16 @@
 {
 	switch (DetectionMethod) {
 	case DDI_POWER_5V_VBUSVALID:
+#ifdef BATT_DBG
+		printk("ddi_power_Get5vPresentFlag--DDI_POWER_5V_VBUSVALID\n");
+#endif
 		/* Check VBUSVALID for 5V present */
 		return ((__raw_readl(REGS_POWER_BASE + HW_POWER_STS) &
 			BM_POWER_STS_VBUSVALID) != 0);
 	case DDI_POWER_5V_VDD5V_GT_VDDIO:
+#ifdef BATT_DBG
+		printk("ddi_power_Get5vPresentFlag--DDI_POWER_5V_VDD5V_GT_VDDIO\n");
+#endif
 		/* Check VDD5V_GT_VDDIO for 5V present */
 		return ((__raw_readl(REGS_POWER_BASE + HW_POWER_STS) &
 			BM_POWER_STS_VDD5V_GT_VDDIO) != 0);
diff --exclude CVS --exclude .git -uNr linux-2.6.35.3/drivers/power/mxs/ddi_power_battery.h linux-2.6.35.3.modified/drivers/power/mxs/ddi_power_battery.h
--- linux-2.6.35.3/drivers/power/mxs/ddi_power_battery.h	2013-05-06 13:03:56.638866802 +0200
+++ linux-2.6.35.3.modified/drivers/power/mxs/ddi_power_battery.h	2013-04-12 11:46:24.150772274 +0200
@@ -42,6 +42,7 @@
 uint16_t ddi_power_convert_setting_to_current(uint16_t u16Setting);
 void ddi_power_enable_5v_to_battery_handoff(void);
 void ddi_power_execute_5v_to_battery_handoff(void);
+void ddi_power_execute_peripheral_shutdown(void);
 void ddi_power_enable_battery_to_5v_handoff(void);
 void ddi_power_execute_battery_to_5v_handoff(void);
 int ddi_power_init_battery(void);
diff --exclude CVS --exclude .git -uNr linux-2.6.35.3/drivers/power/mxs/linux.c linux-2.6.35.3.modified/drivers/power/mxs/linux.c
--- linux-2.6.35.3/drivers/power/mxs/linux.c	2013-05-06 13:04:09.174866803 +0200
+++ linux-2.6.35.3.modified/drivers/power/mxs/linux.c	2013-05-06 12:30:07.708162803 +0200
@@ -34,6 +34,9 @@
 #include <asm/fiq.h>
 #include <linux/pwrsignal.h>
 
+
+
+
 enum application_5v_status{
 	_5v_connected_verified,
 	_5v_connected_unverified,
@@ -115,13 +118,41 @@
  * is online.
  */
 
+#undef BATT_DBG
+
 
 #define is_ac_online()	\
 		(ddi_power_Get5vPresentFlag() ? (!fsl_is_usb_plugged()) : 0)
 #define is_usb_online()	\
 		(ddi_power_Get5vPresentFlag() ? (!!fsl_is_usb_plugged()) : 0)
 
-#ifdef PWRFAIL_SIGNAL
+#ifdef TEST_PWRFAIL_SIGNAL
+#if 1
+static int retentive_shutdown( __attribute__ ((unused)) struct inode *inode,struct file *file,unsigned int cmd,__attribute__ ((unused)) unsigned long arg)
+{
+	int ret = -ENOTTY;
+	
+    if (_IOC_TYPE(cmd) != RETENTIVE_MAGIC)
+        return -ENOTTY;
+
+    if ((_IOC_DIR(cmd) & _IOC_READ) && (!access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd))))
+        return -EFAULT;
+
+    if ((_IOC_DIR(cmd) & _IOC_WRITE) && (!access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd))))
+        return -EFAULT;
+
+    switch (cmd) {
+        case RETENTIVE_POWEROFF:
+	    ddi_power_shutdown();
+            ret = 0;
+            break;
+	default:
+	printk(KERN_WARNING "%s: unknown commmand %d\n", __func__, cmd);
+   }
+   return ret;	
+	
+}
+#endif
 
 struct dentry *file;
 int pid;
@@ -129,6 +160,7 @@
 struct siginfo pwr_sig_info;
 struct task_struct *t;
 
+
 static ssize_t write_pid(struct file *file, const char __user *buf,
 		size_t count, loff_t *ppos)
 {
@@ -162,6 +194,7 @@
 
 static const struct file_operations my_fops = {
 	.write = write_pid,
+	.ioctl = retentive_shutdown
 };
 
 #endif
@@ -245,14 +278,23 @@
 
 static void check_and_handle_5v_connection(struct mxs_info *info)
 {
+#ifdef BATT_DBG
+	//printk("check_and_handle_5v_connection\n");
+#endif
 
 	switch (ddi_power_GetPmu5vStatus()) {
 
 	case new_5v_connection:
+#ifdef BATT_DBG
+	printk("check_and_handle_5v_connection --> case new_5v_connection\n");
+#endif
 		ddi_power_enable_5v_disconnect_detection();
 		info->sm_5v_connection_status = _5v_connected_unverified;
 
 	case existing_5v_connection:
+#ifdef BATT_DBG
+	//printk("check_and_handle_5v_connection --> existing_5v_connection\n");
+#endif
 		if (info->sm_5v_connection_status != _5v_connected_verified) {
 			/* we allow some time to pass before considering
 			 * the 5v connection to be ready to use.  This
@@ -314,7 +356,9 @@
 		break;
 
 	case new_5v_disconnection:
-
+#ifdef BATT_DBG
+	printk("check_and_handle_5v_connection --> new_5v_disconnection\n");
+#endif
 		ddi_bc_SetDisable();
 		ddi_bc_SetCurrentLimit(0);
 		if (info->regulator)
@@ -325,8 +369,37 @@
 
 		info->sm_5v_connection_status = _5v_disconnected_unverified;
 
-	case existing_5v_disconnection:
+		ddi_power_execute_peripheral_shutdown();
+#ifdef TEST_PWRFAIL_SIGNAL
+		if (pid > 0)
+		{
+#ifdef BATT_DBG
+		printk(" 2pid");
+#endif
+			/* send the signal */
+			if (send_sig_info(SIGPWRFAIL, &pwr_sig_info, t) < 0) {
+				printk(KERN_INFO "error sending signal to pid %d\n", pid);
+			}
+			else
+			{
+#ifdef BATT_DBG
+				printk(" sent");
+#endif		
+			}
+		}
+		else
+		{
+#ifdef BATT_DBG
+		printk(" no_pid");
+#endif			
+		}
+#endif
 
+
+	case existing_5v_disconnection:
+#ifdef BATT_DBG
+	printk("C&H --> ex_5v_disc\n");
+#endif
 		if (info->sm_5v_connection_status !=
 			_5v_disconnected_verified) {
 			if ((jiffies - info->sm_new_5v_disconnection_jiffies)
@@ -340,6 +413,9 @@
 				_5V_DEBOUNCE_TIME_MS) {
 				info->sm_5v_connection_status =
 					_5v_disconnected_verified;
+#ifdef BATT_DBG
+	printk("C&H --> ex_5v_disc-->batt\n");
+#endif
 				ddi_power_execute_5v_to_battery_handoff();
 				ddi_power_enable_5v_connect_detection();
 
@@ -726,6 +802,9 @@
 	dev_info(info->dev, "dcdc4p2 brownout interrupt occurred\n");
 
 #endif
+#ifdef BATT_DBG
+		printk("dcdc4p2_bo\n");
+#endif
 	ddi_power_handle_dcdc4p2_bo();
 	return IRQ_HANDLED;
 }
@@ -737,6 +816,9 @@
 	dev_info(info->dev, "battery brownout interrupt occurred\n");
 	ddi_power_disable_power_interrupts();
 #else
+#ifdef BATT_DBG
+		printk("batt_brnout\n");
+#endif
 	ddi_power_shutdown();
 #endif
 	return IRQ_HANDLED;
@@ -750,6 +832,9 @@
 	dev_info(info->dev, "vddd brownout interrupt occurred\n");
 	ddi_power_disable_power_interrupts();
 #else
+#ifdef BATT_DBG
+		printk("vddd_brnout\n");
+#endif
 	ddi_power_shutdown();
 #endif
 	return IRQ_HANDLED;
@@ -761,6 +846,9 @@
 	dev_info(info->dev, "vdda brownout interrupt occurred\n");
 	ddi_power_disable_power_interrupts();
 #else
+#ifdef BATT_DBG
+		printk("vdda_brnout\n");
+#endif
 	ddi_power_shutdown();
 #endif
 	return IRQ_HANDLED;
@@ -772,6 +860,9 @@
 	struct mxs_info *info = (struct mxs_info *)cookie;
 	dev_info(info->dev, "vdd5v droop interrupt occurred\n");
 #endif
+#ifdef BATT_DBG
+		printk("vdd5v_droop\n");
+#endif
 	ddi_power_handle_vdd5v_droop();
 
 	return IRQ_HANDLED;
@@ -786,6 +877,9 @@
 	dev_info(info->dev, "vddio brownout interrupt occurred\n");
 	ddi_power_disable_power_interrupts();
 #else
+#ifdef BATT_DBG
+		printk("vddio_brnout\n");
+#endif
 	ddi_power_handle_vddio_brnout();
 #endif
 	return IRQ_HANDLED;
@@ -801,6 +895,9 @@
 
 		ddi_power_disable_5v_connection_irq();
 		dev_dbg(info->dev, "new 5v connection detected\n");
+#ifdef BATT_DBG
+		printk("new 5v connection detected\n");
+#endif
 		info->sm_new_5v_connection_jiffies = jiffies;
 		mod_timer(&info->sm_timer, jiffies + 1);
 		break;
@@ -814,15 +911,30 @@
 		 * This is handled in the vdd5v_droop interrupt for now.
 		 */
 		/* ddi_power_enable_vddio_interrupt(false); */
-
-#ifdef PWRFAIL_SIGNAL
+		
+#if 0
+		ddi_power_execute_peripheral_shutdown();
+#ifdef BATT_DBG
+		printk(" 1d");
+#endif
+#ifdef TEST_PWRFAIL_SIGNAL
 		if (pid > 0)
 		{
+#ifdef BATT_DBG
+		printk(" 2p");
+#endif
 			/* send the signal */
 			if (send_sig_info(SIGPWRFAIL, &pwr_sig_info, t) < 0) {
 				printk(KERN_INFO "error sending signal to pid %d\n", pid);
 			}
 		}
+		else
+		{
+#ifdef BATT_DBG
+		printk(" no_pid");
+#endif			
+		}
+#endif
 #endif
 
 		ddi_power_disable_5v_connection_irq();
@@ -832,7 +944,9 @@
 		break;
 
 	default:
-
+#ifdef BATT_DBG
+		printk("default\n");
+#endif
 		break;
 
 	}
@@ -1278,7 +1392,7 @@
 
 	ret = platform_driver_register(&mxs_batdrv);
 
-#ifdef PWRFAIL_SIGNAL
+#ifdef TEST_PWRFAIL_SIGNAL
 	/* only root can write to this file (no read) */
 	file = debugfs_create_file("signalconfpid", 0200, NULL, NULL, &my_fops);
 	pid = 0;
@@ -1289,7 +1403,7 @@
 static void __exit mxs_bat_exit(void)
 {
 	platform_driver_unregister(&mxs_batdrv);
-#ifdef PWRFAIL_SIGNAL
+#ifdef TEST_PWRFAIL_SIGNAL
 	if (file)
 		debugfs_remove(file);
 #endif
diff --exclude CVS --exclude .git -uNr linux-2.6.35.3/include/linux/gpio_pwrfail.h linux-2.6.35.3.modified/include/linux/gpio_pwrfail.h
--- linux-2.6.35.3/include/linux/gpio_pwrfail.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.3.modified/include/linux/gpio_pwrfail.h	2013-05-06 12:25:16.668161110 +0200
@@ -0,0 +1,21 @@
+#ifndef _GPIO_PWRFAIL_H
+#define _GPIO_PWRFAIL_H
+
+
+#include <linux/pwrsignal.h>
+
+
+struct gpio_pwrfail {
+	int gpio;
+	char *desc;
+#ifdef __KERNEL__
+	bool can_disable;
+#endif
+};
+
+struct gpio_pwrfail_platform_data {
+	struct gpio_pwrfail *pwrfails;
+	int npwrfails;
+};
+
+#endif
diff --exclude CVS --exclude .git -uNr linux-2.6.35.3/include/linux/pwrsignal.h linux-2.6.35.3.modified/include/linux/pwrsignal.h
--- linux-2.6.35.3/include/linux/pwrsignal.h	2013-05-06 13:04:09.058866803 +0200
+++ linux-2.6.35.3.modified/include/linux/pwrsignal.h	2013-05-06 12:24:10.652162826 +0200
@@ -13,6 +13,24 @@
 #define PWRFAIL_SIGNAL
 #define DBGFS_ROOT    "/sys/kernel/debug/"
 #define PID_FILE    "signalconfpid"
+#define PID_PATH	"/sys/kernel/debug/signalconfpid"
 #define SIGPWRFAIL  44
 
+#ifdef PWRFAIL_SIGNAL
+#undef PWRFAIL_DEBUG
+#if 1
+#ifdef __KERNEL__
+#include <asm/ioctl.h>
+#else
+#include <sys/ioctl.h>
+#endif
+#define RETENTIVE_MAGIC 'r'
+#define RETENTIVE_POWEROFF _IO(RETENTIVE_MAGIC, 0)
+#ifdef PWRFAIL_DEBUG
+#define RETENTIVE_GPIOCTRL _IO(RETENTIVE_MAGIC, 1)
+#endif
+#endif
+
+#endif //PWRFAIL_SIGNAL
+
 #endif
