--- linux-2.6.35.3_ipipe/arch/arm/plat-mxs/timer-match.c	2012-10-02 14:43:21.921391931 +0200
+++ linux-2.6.35.3_ipipe_2012-07-11/arch/arm/plat-mxs/timer-match_2012-07-11.c	2012-10-02 14:46:49.125738000 +0200
@@ -45,6 +45,99 @@
 // #include <mach/regs-digctl.h>
 #define HW_DIGCTL_MICROSECONDS  (0x000000c0)
 
+#define TRACE_GPIO
+#ifdef  TRACE_GPIO
+
+// 0 XX_SET(a) TASTO1  PINID_SSP3_SCK   MXS_PIN_ENCODE(2, 24)
+#define XX_PORTa       2
+#define XX_PINa                24
+#define XX_GPIOa       MXS_PIN_TO_GPIO(MXS_PIN_ENCODE(XX_PORTa, XX_PINa))
+#define XX_MASKa       (1 << XX_PINa)
+#define XX_MUXSELa_value       0x00030000
+#define XX_MUXSELa_offset              0x0154  // set gpio
+#define XX_DRIVEaS_value       0x00000004
+#define XX_DRIVEaS_offset              0x03b4  // set drive 3.3V
+#define XX_DRIVEaC_value       0x00000003
+#define XX_DRIVEaC_offset              0x03b8  // set drive 4mA
+#define XX_PULLaC_offset               0x0628  // set no pullup
+#define XX_DOUTaS_offset               0x0724  // set output 1
+#define XX_DOEaS_offset                0x0b24          // set output enable
+#define XX_DOUTaC_offset               0x0728  // set output 0
+
+// 1 XX_SET(b) TASTO2  PINID_SSP1_DATA0 MXS_PIN_ENCODE(2, 14)
+#define XX_PORTb       2
+#define XX_PINb                14
+#define XX_GPIOb       MXS_PIN_TO_GPIO(MXS_PIN_ENCODE(XX_PORTb, XX_PINb))
+#define XX_MASKb       (1 << XX_PINb)
+#define XX_MUXSELb_value       0x30000000
+#define XX_MUXSELb_offset              0x0144  // set gpio
+#define XX_DRIVEbS_value       0x04000000
+#define XX_DRIVEbS_offset              0x0394  // set drive 3.3V
+#define XX_DRIVEbC_value       0x03000000
+#define XX_DRIVEbC_offset              0x0398  // set drive 4mA
+#define XX_PULLbC_offset               0x0628  // set no pullup
+#define XX_DOUTbS_offset               0x0724  // set output 1
+#define XX_DOEbS_offset                0x0b24          // set output enable
+#define XX_DOUTbC_offset               0x0728  // set output 0
+
+// 2 XX_SET(c) TASTO3  PINID_SSP3_SS0   MXS_PIN_ENCODE(2, 27)
+#define XX_PORTc       2
+#define XX_PINc                27
+#define XX_GPIOc       MXS_PIN_TO_GPIO(MXS_PIN_ENCODE(XX_PORTc, XX_PINc))
+#define XX_MASKc       (1 << XX_PINc)
+#define XX_MUXSELc_value       0x00c00000
+#define XX_MUXSELc_offset              0x0154  // set gpio
+#define XX_DRIVEcS_value       0x00004000
+#define XX_DRIVEcS_offset              0x03b4  // set drive 3.3V
+#define XX_DRIVEcC_value       0x00003000
+#define XX_DRIVEcC_offset              0x03b8  // set drive 4mA
+#define XX_PULLcC_offset               0x0628  // set no pullup
+#define XX_DOUTcS_offset               0x0724  // set output 1
+#define XX_DOEcS_offset                0x0b24          // set output enable
+#define XX_DOUTcC_offset               0x0728  // set output 0
+
+// 3 XX_SET(d) TASTO4  PINID_SSP2_MOSI  MXS_PIN_ENCODE(2, 17)
+// 4 XX_SET(e) TASTO5  PINID_SSP2_MISO  MXS_PIN_ENCODE(2, 18)
+// 5 XX_SET(f) TASTO6  PINID_SSP2_SCK   MXS_PIN_ENCODE(2, 16)
+
+static void __iomem *xx_base = IO_ADDRESS(PINCTRL_PHYS_ADDR);
+
+// vedi linux/arch/arm/mach-mx28/mx28evk_pins.c
+        //xx_gpio_ok = gpio_request(MXS_PIN_TO_GPIO(MXS_PIN_ENCODE(XX_PORT, XX_PIN)), XX_NAME);
+       //mxs_set_strength(MXS_PIN_ENCODE(XX_PORT, XX_PIN), PAD_4MA, XX_NAME);
+       //mxs_set_voltage(MXS_PIN_ENCODE(XX_PORT, XX_PIN), PAD_3_3V, XX_NAME);
+       //gpio_direction_output(MXS_PIN_TO_GPIO(MXS_PIN_ENCODE(XX_PORT, XX_PIN)), 1);
+       //gpio_set_value(MXS_PIN_TO_GPIO(MXS_PIN_ENCODE(XX_PORT, XX_PIN)), 1);
+#define XX_PREPARE(x) \
+       do { \
+       __raw_writel(XX_MUXSEL##x##_value, xx_base + XX_MUXSEL##x##_offset); \
+       __raw_writel(XX_DRIVE##x##S_value, xx_base + XX_DRIVE##x##S_offset); \
+       __raw_writel(XX_DRIVE##x##C_value, xx_base + XX_DRIVE##x##C_offset); \
+       __raw_writel(XX_MASK##x,           xx_base + XX_PULL##x##C_offset); \
+       __raw_writel(XX_MASK##x,           xx_base + XX_DOUT##x##C_offset); \
+       __raw_writel(XX_MASK##x,           xx_base + XX_DOE##x##S_offset);  \
+       } while (0)
+
+       // gpio_set_value(MXS_PIN_TO_GPIO(MXS_PIN_ENCODE(XX_PORT, XX_PIN)), 0);
+#define XX_SET(x) \
+       do { \
+       __raw_writel(XX_MASK##x,           xx_base + XX_DOUT##x##S_offset); \
+       } while (0)
+
+       // gpio_set_value(MXS_PIN_TO_GPIO(MXS_PIN_ENCODE(XX_PORT, XX_PIN)), 0);
+#define XX_CLR(x) \
+       do { \
+       __raw_writel(XX_MASK##x,           xx_base + XX_DOUT##x##C_offset); \
+       } while (0)
+
+#else /* TRACE_GPIO */
+#define XX_PREPARE(v)
+#define XX_SET(v)
+#define XX_CLR(v)
+
+#endif
+
+
 static inline void gpt_irq_acknowledge(void)
 {
 	__raw_writel(BM_TIMROT_TIMCTRLn_IRQ, online_timer->base + HW_TIMROT_TIMCTRLn_CLR(online_timer->id));
@@ -237,6 +330,7 @@
 static irqreturn_t mxs_timer_handler(int irq, void *dev_id)
 {
 	struct clock_event_device *c = dev_id;
+	XX_SET(a);
 #ifndef CONFIG_IPIPE
 	if (__raw_readl(online_timer->base +
 			HW_TIMROT_TIMCTRLn(online_timer->id)) &
@@ -252,6 +346,7 @@
 #endif
 		c->event_handler(c);
 	}
+	XX_CLR(a);
 	return IRQ_HANDLED;
 }
 
@@ -278,6 +373,7 @@
 	__raw_writel(BF_TIMROT_TIMCTRLn_SELECT(online_timer->clk_sel), online_timer->base + HW_TIMROT_TIMCTRLn(online_timer->id));
 	__raw_writel(BM_TIMROT_TIMCTRLn_MATCH_MODE                   , online_timer->base + HW_TIMROT_TIMCTRLn_SET(online_timer->id));
 #endif
+	XX_PREPARE(a);
 #ifdef CONFIG_IPIPE
 	__ipipe_mach_timerint = online_timer->irq;
 	__ipipe_mach_ticks_per_jiffy = (clk_get_rate(online_timer->clk) + HZ/2) / HZ;
@@ -305,4 +401,3 @@
 	setup_irq(online_timer->irq, &mxs_timer_irq);
 }
 
-
