diff -rup gdb-7.4ori//gdb/acinclude.m4 gdb-7.4/gdb/acinclude.m4
--- gdb-7.4ori//gdb/acinclude.m4	2010-05-27 05:40:45.000000000 +0200
+++ gdb-7.4/gdb/acinclude.m4	2012-05-10 11:26:26.319643428 +0200
@@ -1,3 +1,5 @@
+# serial 1
+
 dnl written by Rob Savoye <rob@cygnus.com> for Cygnus Support
 dnl major rewriting for Tcl 7.5 by Don Libes <libes@nist.gov>

@@ -81,8 +83,6 @@ AC_MSG_RESULT(yes)
 # Foundation, Inc., 51 Franklin Street, Fifth Floor,
 # Boston, MA 02110-1301, USA.

-# serial 1
-
 # @defmac AC_PROG_CC_STDC
 # @maindex PROG_CC_STDC
 # @ovindex CC
diff -rup gdb-7.4ori//gdb/aclocal.m4 gdb-7.4/gdb/aclocal.m4
--- gdb-7.4ori//gdb/aclocal.m4	2011-02-15 22:05:53.000000000 +0100
+++ gdb-7.4/gdb/aclocal.m4	2012-05-10 11:26:26.315643428 +0200
@@ -19,6 +19,162 @@ You have another version of autoconf.  I
 If you have problems, you may need to regenerate the build system entirely.
 To do so, use the procedure documented by the package, typically `autoreconf'.])])

+# pkg.m4 - Macros to locate and utilise pkg-config.            -*- Autoconf -*-
+#
+# Copyright Â© 2004 Scott James Remnant <scott@netsplit.com>.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# PKG_PROG_PKG_CONFIG([MIN-VERSION])
+# ----------------------------------
+AC_DEFUN([PKG_PROG_PKG_CONFIG],
+[m4_pattern_forbid([^_?PKG_[A-Z_]+$])
+m4_pattern_allow([^PKG_CONFIG(_PATH)?$])
+AC_ARG_VAR([PKG_CONFIG], [path to pkg-config utility])dnl
+if test "x$ac_cv_env_PKG_CONFIG_set" != "xset"; then
+	AC_PATH_TOOL([PKG_CONFIG], [pkg-config])
+fi
+if test -n "$PKG_CONFIG"; then
+	_pkg_min_version=m4_default([$1], [0.9.0])
+	AC_MSG_CHECKING([pkg-config is at least version $_pkg_min_version])
+	if $PKG_CONFIG --atleast-pkgconfig-version $_pkg_min_version; then
+		AC_MSG_RESULT([yes])
+	else
+		AC_MSG_RESULT([no])
+		PKG_CONFIG=""
+	fi
+
+fi[]dnl
+])# PKG_PROG_PKG_CONFIG
+
+# PKG_CHECK_EXISTS(MODULES, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
+#
+# Check to see whether a particular set of modules exists.  Similar
+# to PKG_CHECK_MODULES(), but does not set variables or print errors.
+#
+#
+# Similar to PKG_CHECK_MODULES, make sure that the first instance of
+# this or PKG_CHECK_MODULES is called, or make sure to call
+# PKG_CHECK_EXISTS manually
+# --------------------------------------------------------------
+AC_DEFUN([PKG_CHECK_EXISTS],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+if test -n "$PKG_CONFIG" && \
+    AC_RUN_LOG([$PKG_CONFIG --exists --print-errors "$1"]); then
+  m4_ifval([$2], [$2], [:])
+m4_ifvaln([$3], [else
+  $3])dnl
+fi])
+
+
+# _PKG_CONFIG([VARIABLE], [COMMAND], [MODULES])
+# ---------------------------------------------
+m4_define([_PKG_CONFIG],
+[if test -n "$$1"; then
+    pkg_cv_[]$1="$$1"
+ elif test -n "$PKG_CONFIG"; then
+    PKG_CHECK_EXISTS([$3],
+                     [pkg_cv_[]$1=`$PKG_CONFIG --[]$2 "$3" 2>/dev/null`],
+		     [pkg_failed=yes])
+ else
+    pkg_failed=untried
+fi[]dnl
+])# _PKG_CONFIG
+
+# _PKG_SHORT_ERRORS_SUPPORTED
+# -----------------------------
+AC_DEFUN([_PKG_SHORT_ERRORS_SUPPORTED],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])
+if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
+        _pkg_short_errors_supported=yes
+else
+        _pkg_short_errors_supported=no
+fi[]dnl
+])# _PKG_SHORT_ERRORS_SUPPORTED
+
+
+# PKG_CHECK_MODULES(VARIABLE-PREFIX, MODULES, [ACTION-IF-FOUND],
+# [ACTION-IF-NOT-FOUND])
+#
+#
+# Note that if there is a possibility the first call to
+# PKG_CHECK_MODULES might not happen, you should be sure to include an
+# explicit call to PKG_PROG_PKG_CONFIG in your configure.ac
+#
+#
+# --------------------------------------------------------------
+AC_DEFUN([PKG_CHECK_MODULES],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+AC_ARG_VAR([$1][_CFLAGS], [C compiler flags for $1, overriding pkg-config])dnl
+AC_ARG_VAR([$1][_LIBS], [linker flags for $1, overriding pkg-config])dnl
+
+pkg_failed=no
+AC_MSG_CHECKING([for $1])
+
+_PKG_CONFIG([$1][_CFLAGS], [cflags], [$2])
+_PKG_CONFIG([$1][_LIBS], [libs], [$2])
+
+m4_define([_PKG_TEXT], [Alternatively, you may set the environment variables $1[]_CFLAGS
+and $1[]_LIBS to avoid the need to call pkg-config.
+See the pkg-config man page for more details.])
+
+if test $pkg_failed = yes; then
+        _PKG_SHORT_ERRORS_SUPPORTED
+        if test $_pkg_short_errors_supported = yes; then
+	        $1[]_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors "$2" 2>&1`
+        else
+	        $1[]_PKG_ERRORS=`$PKG_CONFIG --print-errors "$2" 2>&1`
+        fi
+	# Put the nasty error message in config.log where it belongs
+	echo "$$1[]_PKG_ERRORS" >&AS_MESSAGE_LOG_FD
+
+	ifelse([$4], , [AC_MSG_ERROR(dnl
+[Package requirements ($2) were not met:
+
+$$1_PKG_ERRORS
+
+Consider adjusting the PKG_CONFIG_PATH environment variable if you
+installed software in a non-standard prefix.
+
+_PKG_TEXT
+])],
+		[AC_MSG_RESULT([no])
+                $4])
+elif test $pkg_failed = untried; then
+	ifelse([$4], , [AC_MSG_FAILURE(dnl
+[The pkg-config script could not be found or is too old.  Make sure it
+is in your PATH or set the PKG_CONFIG environment variable to the full
+path to pkg-config.
+
+_PKG_TEXT
+
+To get pkg-config, see <http://pkg-config.freedesktop.org/>.])],
+		[$4])
+else
+	$1[]_CFLAGS=$pkg_cv_[]$1[]_CFLAGS
+	$1[]_LIBS=$pkg_cv_[]$1[]_LIBS
+        AC_MSG_RESULT([yes])
+	ifelse([$3], , :, [$3])
+fi[]dnl
+])# PKG_CHECK_MODULES
+
 # Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
diff -rup gdb-7.4ori//gdb/config.in gdb-7.4/gdb/config.in
--- gdb-7.4ori//gdb/config.in	2011-11-20 09:59:56.000000000 +0100
+++ gdb-7.4/gdb/config.in	2012-05-10 11:26:26.315643428 +0200
@@ -46,6 +46,9 @@
 /* Define to BFD's default target vector. */
 #undef DEFAULT_BFD_VEC

+/* librpm version specific library name to dlopen. */
+#undef DLOPEN_LIBRPM
+
 /* Define to 1 if translation of program messages to the user's native
    language is requested. */
 #undef ENABLE_NLS
@@ -233,6 +236,9 @@
 /* Define if Python 2.7 is being used. */
 #undef HAVE_LIBPYTHON2_7

+/* Define if librpm library is being used. */
+#undef HAVE_LIBRPM
+
 /* Define if libunwind library is being used. */
 #undef HAVE_LIBUNWIND

diff -rup gdb-7.4ori//gdb/configure gdb-7.4/gdb/configure
--- gdb-7.4ori//gdb/configure	2011-12-13 14:08:05.000000000 +0100
+++ gdb-7.4/gdb/configure	2012-05-10 11:26:26.319643428 +0200
@@ -684,6 +684,9 @@ REPORT_BUGS_TO
 PKGVERSION
 TARGET_OBS
 subdirs
+RPM_LIBS
+RPM_CFLAGS
+PKG_CONFIG
 GDB_DATADIR
 DEBUGDIR
 am__fastdepCC_FALSE
@@ -952,6 +955,7 @@ enable_dependency_tracking
 with_separate_debug_dir
 with_gdb_datadir
 with_relocated_sources
+with_rpm
 enable_targets
 enable_64_bit_bfd
 enable_gdbcli
@@ -995,6 +999,9 @@ LDFLAGS
 LIBS
 CPPFLAGS
 CPP
+PKG_CONFIG
+RPM_CFLAGS
+RPM_LIBS
 MAKEINFO
 MAKEINFOFLAGS
 YACC
@@ -1658,6 +1665,8 @@ Optional Packages:
                           [DATADIR/gdb]
   --with-relocated-sources=PATH
                           automatically relocate this path for source files
+  --with-rpm              query rpm database for missing debuginfos (yes/no,
+                          def. auto=librpm.so)
   --with-libunwind        use libunwind frame unwinding support
   --with-curses           use the curses library instead of the termcap
                           library
@@ -1696,6 +1705,9 @@ Some influential environment variables:
   CPPFLAGS    C/C++/Objective C preprocessor flags, e.g. -I<include dir> if
               you have headers in a nonstandard directory <include dir>
   CPP         C preprocessor
+  PKG_CONFIG  path to pkg-config utility
+  RPM_CFLAGS  C compiler flags for RPM, overriding pkg-config
+  RPM_LIBS    linker flags for RPM, overriding pkg-config
   MAKEINFO    Parent configure detects if it is of sufficient version.
   MAKEINFOFLAGS
   YACC        The `Yet Another C Compiler' implementation to use. Defaults to
@@ -7968,6 +7980,486 @@ _ACEOF
 fi


+# Integration with rpm library to support missing debuginfo suggestions.
+# --without-rpm: Disable any rpm support.
+# --with-rpm=libname.so: Try to dynamically open `libname.so' during runtime.
+#   Even with runtime missing `libname.so' GDB will still other run correctly.
+#   Missing `libname.so' during ./configure will abort the configuration.
+# --with-rpm=librpm.so: Like `--with-rpm=libname.so' but try to find specific
+#   minor version first such as `librpm-4.6.so' as minor version differences
+#   mean API+ABI incompatibility.  If the specific match versioned library name
+#   could not be found still open dynamically at least `librpm.so'.
+# --with-rpm: Like `--with-rpm=librpm.so' but if any of its detection fails try
+#   to find librpm for compilation-time linking by pkg-config.  GDB binary will
+#   be probably linked with the version specific library (as `librpm-4.6.so').
+#   Failure to find librpm by pkg-config will abort the configuration.
+# (default) --with-rpm=auto: Like `--with-rpm=librpm.so' but if even pkg-config
+#   cannot find librpm use to the rpmless compilation (like `--without-rpm').
+
+
+# Check whether --with-rpm was given.
+if test "${with_rpm+set}" = set; then :
+  withval=$with_rpm;
+else
+  with_rpm="auto"
+fi
+
+
+
+
+if test "x$with_rpm" != "xno"; then
+  if test "x$with_rpm" = "xyes"; then
+    LIBRPM="librpm.so"
+    RPM_REQUIRE=true
+    DLOPEN_REQUIRE=false
+  elif test "x$with_rpm" = "xauto"; then
+    LIBRPM="librpm.so"
+    RPM_REQUIRE=false
+    DLOPEN_REQUIRE=false
+  else
+    LIBRPM="$with_rpm"
+    RPM_REQUIRE=true
+    DLOPEN_REQUIRE=true
+  fi
+  LIBRPM_STRING='"'"$LIBRPM"'"'
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking specific librpm version" >&5
+$as_echo_n "checking specific librpm version... " >&6; }
+  HAVE_DLOPEN_LIBRPM=false
+  save_LIBS="$LIBS"
+  LIBS="$LIBS -ldl"
+  if test "$cross_compiling" = yes; then :
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "cannot run test program while cross compiling
+See \`config.log' for more details." "$LINENO" 5; }
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <rpm/rpmlib.h>
+#include <dlfcn.h>
+#include <errno.h>
+
+int
+main ()
+{
+
+    void *h;
+    const char *const *rpmverp;
+    FILE *f;
+
+    f = fopen ("conftest.out", "w");
+    if (!f)
+      {
+	fprintf (stderr, "Cannot write \"%s\": %s\n", "conftest.out",
+		 strerror (errno));
+	return 1;
+      }
+    h = dlopen ($LIBRPM_STRING, RTLD_LAZY);
+    if (!h)
+      {
+	fprintf (stderr, "dlopen (\"%s\"): %s\n", $LIBRPM_STRING, dlerror ());
+	return 1;
+      }
+    rpmverp = dlsym (h, "RPMVERSION");
+    if (!rpmverp)
+      {
+	fprintf (stderr, "dlsym (\"RPMVERSION\"): %s\n", dlerror ());
+	return 1;
+      }
+    fprintf (stderr, "RPMVERSION is: \"");
+    fprintf (stderr, "%s\"\n", *rpmverp);
+
+    /* Try to find the specific librpm version only for "librpm.so" as we do
+       not know how to assemble the version string otherwise.  */
+
+    if (strcmp ("librpm.so", $LIBRPM_STRING) != 0)
+      {
+	fprintf (f, "%s\n", $LIBRPM_STRING);
+	return 0;
+      }
+    else
+      {
+	char *h2_name;
+	void *h2;
+	int major, minor;
+
+	if (sscanf (*rpmverp, "%d.%d", &major, &minor) != 2)
+	  {
+	    fprintf (stderr, "Unable to parse RPMVERSION.\n");
+	    fprintf (f, "%s\n", $LIBRPM_STRING);
+	    return 0;
+	  }
+	/* Avoid the square brackets by malloc.  */
+	h2_name = malloc (64);
+	sprintf (h2_name, "librpm-%d.%d.so", major, minor);
+	h2 = dlopen (h2_name, RTLD_LAZY);
+	if (!h2)
+	  {
+	    fprintf (stderr, "dlopen (\"%s\"): %s\n", h2_name, dlerror ());
+	    fprintf (f, "%s\n", $LIBRPM_STRING);
+	    return 0;
+	  }
+	if (h2 != h)
+	  {
+	    fprintf (stderr, "dlopen of \"%s\" and \"%s\" are different.\n",
+		     $LIBRPM_STRING, h2_name);
+	    fprintf (f, "%s\n", $LIBRPM_STRING);
+	    return 0;
+	  }
+	/* Found the valid .so name with a specific version.  */
+	fprintf (f, "%s\n", h2_name);
+	return 0;
+      }
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+
+    DLOPEN_LIBRPM="`cat conftest.out`"
+    if test "x$DLOPEN_LIBRPM" != "x"; then
+      HAVE_DLOPEN_LIBRPM=true
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DLOPEN_LIBRPM" >&5
+$as_echo "$DLOPEN_LIBRPM" >&6; }
+    fi
+
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+  rm -f conftest.out
+
+
+
+  if $HAVE_DLOPEN_LIBRPM; then
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking rpm library API compatibility" >&5
+$as_echo_n "checking rpm library API compatibility... " >&6; }
+    # The compilation requires -Werror to verify anything.
+    save_CFLAGS="$CFLAGS"
+    CFLAGS="$CFLAGS -Werror"
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Duplicate here the declarations to verify they match "elfread.c".  */
+#include <rpm/rpmlib.h>
+#include <rpm/rpmts.h>
+#include <rpm/rpmdb.h>
+#include <rpm/header.h>
+extern char * headerFormat(Header h, const char * fmt, errmsg_t * errmsg);
+extern int rpmReadConfigFiles(const char * file, const char * target);
+extern rpmdbMatchIterator rpmdbFreeIterator(rpmdbMatchIterator mi);
+extern Header rpmdbNextIterator(rpmdbMatchIterator mi);
+extern rpmts rpmtsCreate(void);
+extern rpmts rpmtsFree(rpmts ts);
+extern rpmdbMatchIterator rpmtsInitIterator(const rpmts ts, rpmTag rpmtag,
+					    const void * keyp, size_t keylen);
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+      LIBRPM_COMPAT=true
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+else
+
+      LIBRPM_COMPAT=false
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+    CFLAGS="$save_CFLAGS"
+
+    if ! $LIBRPM_COMPAT; then
+      HAVE_DLOPEN_LIBRPM=false
+    fi
+  fi
+
+  if $HAVE_DLOPEN_LIBRPM; then
+    DLOPEN_LIBRPM_STRING='"'"$DLOPEN_LIBRPM"'"'
+
+cat >>confdefs.h <<_ACEOF
+#define DLOPEN_LIBRPM $DLOPEN_LIBRPM_STRING
+_ACEOF
+
+
+$as_echo "#define HAVE_LIBRPM 1" >>confdefs.h
+
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    LIBS="$save_LIBS"
+    if $DLOPEN_REQUIRE; then
+      as_fn_error "Specific name $LIBRPM was requested but it could not be opened." "$LINENO" 5
+    fi
+
+
+if test "x$ac_cv_env_PKG_CONFIG_set" != "xset"; then
+	if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}pkg-config", so it can be a program name with args.
+set dummy ${ac_tool_prefix}pkg-config; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_path_PKG_CONFIG+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $PKG_CONFIG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_PKG_CONFIG="$PKG_CONFIG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+PKG_CONFIG=$ac_cv_path_PKG_CONFIG
+if test -n "$PKG_CONFIG"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $PKG_CONFIG" >&5
+$as_echo "$PKG_CONFIG" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_path_PKG_CONFIG"; then
+  ac_pt_PKG_CONFIG=$PKG_CONFIG
+  # Extract the first word of "pkg-config", so it can be a program name with args.
+set dummy pkg-config; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_path_ac_pt_PKG_CONFIG+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $ac_pt_PKG_CONFIG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_ac_pt_PKG_CONFIG="$ac_pt_PKG_CONFIG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_ac_pt_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+ac_pt_PKG_CONFIG=$ac_cv_path_ac_pt_PKG_CONFIG
+if test -n "$ac_pt_PKG_CONFIG"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_pt_PKG_CONFIG" >&5
+$as_echo "$ac_pt_PKG_CONFIG" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_pt_PKG_CONFIG" = x; then
+    PKG_CONFIG=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    PKG_CONFIG=$ac_pt_PKG_CONFIG
+  fi
+else
+  PKG_CONFIG="$ac_cv_path_PKG_CONFIG"
+fi
+
+fi
+if test -n "$PKG_CONFIG"; then
+	_pkg_min_version=0.9.0
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking pkg-config is at least version $_pkg_min_version" >&5
+$as_echo_n "checking pkg-config is at least version $_pkg_min_version... " >&6; }
+	if $PKG_CONFIG --atleast-pkgconfig-version $_pkg_min_version; then
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	else
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+		PKG_CONFIG=""
+	fi
+
+fi
+
+pkg_failed=no
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for RPM" >&5
+$as_echo_n "checking for RPM... " >&6; }
+
+if test -n "$RPM_CFLAGS"; then
+    pkg_cv_RPM_CFLAGS="$RPM_CFLAGS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"rpm\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "rpm") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_RPM_CFLAGS=`$PKG_CONFIG --cflags "rpm" 2>/dev/null`
+else
+  pkg_failed=yes
+fi
+ else
+    pkg_failed=untried
+fi
+if test -n "$RPM_LIBS"; then
+    pkg_cv_RPM_LIBS="$RPM_LIBS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"rpm\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "rpm") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_RPM_LIBS=`$PKG_CONFIG --libs "rpm" 2>/dev/null`
+else
+  pkg_failed=yes
+fi
+ else
+    pkg_failed=untried
+fi
+
+
+
+if test $pkg_failed = yes; then
+
+if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
+        _pkg_short_errors_supported=yes
+else
+        _pkg_short_errors_supported=no
+fi
+        if test $_pkg_short_errors_supported = yes; then
+	        RPM_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors "rpm" 2>&1`
+        else
+	        RPM_PKG_ERRORS=`$PKG_CONFIG --print-errors "rpm" 2>&1`
+        fi
+	# Put the nasty error message in config.log where it belongs
+	echo "$RPM_PKG_ERRORS" >&5
+
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+                HAVE_LIBRPM=false
+elif test $pkg_failed = untried; then
+	HAVE_LIBRPM=false
+else
+	RPM_CFLAGS=$pkg_cv_RPM_CFLAGS
+	RPM_LIBS=$pkg_cv_RPM_LIBS
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	HAVE_LIBRPM=true
+fi
+
+    if $HAVE_LIBRPM; then
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking rpm library API compatibility" >&5
+$as_echo_n "checking rpm library API compatibility... " >&6; }
+    # The compilation requires -Werror to verify anything.
+    save_CFLAGS="$CFLAGS"
+    CFLAGS="$CFLAGS -Werror"
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Duplicate here the declarations to verify they match "elfread.c".  */
+#include <rpm/rpmlib.h>
+#include <rpm/rpmts.h>
+#include <rpm/rpmdb.h>
+#include <rpm/header.h>
+extern char * headerFormat(Header h, const char * fmt, errmsg_t * errmsg);
+extern int rpmReadConfigFiles(const char * file, const char * target);
+extern rpmdbMatchIterator rpmdbFreeIterator(rpmdbMatchIterator mi);
+extern Header rpmdbNextIterator(rpmdbMatchIterator mi);
+extern rpmts rpmtsCreate(void);
+extern rpmts rpmtsFree(rpmts ts);
+extern rpmdbMatchIterator rpmtsInitIterator(const rpmts ts, rpmTag rpmtag,
+					    const void * keyp, size_t keylen);
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+      LIBRPM_COMPAT=true
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+else
+
+      LIBRPM_COMPAT=false
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+    CFLAGS="$save_CFLAGS"
+
+      if ! $LIBRPM_COMPAT; then
+	HAVE_LIBRPM=false
+	RPM_PKG_ERRORS="Found $LIBRPM API is incompatibile with this GDB"
+      fi
+    fi
+
+    if $HAVE_LIBRPM; then
+
+$as_echo "#define HAVE_LIBRPM 1" >>confdefs.h
+
+      CFLAGS="$CFLAGS $RPM_CFLAGS"
+      LIBS="$LIBS $RPM_LIBS"
+    else
+      if $RPM_REQUIRE; then
+	as_fn_error "$RPM_PKG_ERRORS" "$LINENO" 5
+      else
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $RPM_PKG_ERRORS" >&5
+$as_echo "$as_me: WARNING: $RPM_PKG_ERRORS" >&2;}
+      fi
+    fi
+  fi
+fi
+


 subdirs="$subdirs testsuite"
diff -rup gdb-7.4ori//gdb/configure.ac gdb-7.4/gdb/configure.ac
--- gdb-7.4ori//gdb/configure.ac	2012-01-06 05:43:06.000000000 +0100
+++ gdb-7.4/gdb/configure.ac	2012-05-10 11:26:26.319643428 +0200
@@ -138,6 +138,199 @@ AS_HELP_STRING([--with-relocated-sources
               [Relocated directory for source files. ])
 ])

+# Integration with rpm library to support missing debuginfo suggestions.
+# --without-rpm: Disable any rpm support.
+# --with-rpm=libname.so: Try to dynamically open `libname.so' during runtime.
+#   Even with runtime missing `libname.so' GDB will still other run correctly.
+#   Missing `libname.so' during ./configure will abort the configuration.
+# --with-rpm=librpm.so: Like `--with-rpm=libname.so' but try to find specific
+#   minor version first such as `librpm-4.6.so' as minor version differences
+#   mean API+ABI incompatibility.  If the specific match versioned library name
+#   could not be found still open dynamically at least `librpm.so'.
+# --with-rpm: Like `--with-rpm=librpm.so' but if any of its detection fails try
+#   to find librpm for compilation-time linking by pkg-config.  GDB binary will
+#   be probably linked with the version specific library (as `librpm-4.6.so').
+#   Failure to find librpm by pkg-config will abort the configuration.
+# (default) --with-rpm=auto: Like `--with-rpm=librpm.so' but if even pkg-config
+#   cannot find librpm use to the rpmless compilation (like `--without-rpm').
+
+AC_ARG_WITH([rpm],
+  [AS_HELP_STRING([--with-rpm],
+                  [query rpm database for missing debuginfos (yes/no, def. auto=librpm.so)])], [], [with_rpm="auto"])
+
+m4_pattern_allow([^AC_MSG_ERROR$])
+m4_pattern_allow([^AC_MSG_WARN$])
+if test "x$with_rpm" != "xno"; then
+  if test "x$with_rpm" = "xyes"; then
+    LIBRPM="librpm.so"
+    RPM_REQUIRE=true
+    DLOPEN_REQUIRE=false
+  elif test "x$with_rpm" = "xauto"; then
+    LIBRPM="librpm.so"
+    RPM_REQUIRE=false
+    DLOPEN_REQUIRE=false
+  else
+    LIBRPM="$with_rpm"
+    RPM_REQUIRE=true
+    DLOPEN_REQUIRE=true
+  fi
+  LIBRPM_STRING='"'"$LIBRPM"'"'
+
+  AC_MSG_CHECKING([specific librpm version])
+  HAVE_DLOPEN_LIBRPM=false
+  save_LIBS="$LIBS"
+  LIBS="$LIBS -ldl"
+  AC_RUN_IFELSE(AC_LANG_PROGRAM([[
+#include <rpm/rpmlib.h>
+#include <dlfcn.h>
+#include <errno.h>
+  ]], [[
+    void *h;
+    const char *const *rpmverp;
+    FILE *f;
+
+    f = fopen ("conftest.out", "w");
+    if (!f)
+      {
+	fprintf (stderr, "Cannot write \"%s\": %s\n", "conftest.out",
+		 strerror (errno));
+	return 1;
+      }
+    h = dlopen ($LIBRPM_STRING, RTLD_LAZY);
+    if (!h)
+      {
+	fprintf (stderr, "dlopen (\"%s\"): %s\n", $LIBRPM_STRING, dlerror ());
+	return 1;
+      }
+    rpmverp = dlsym (h, "RPMVERSION");
+    if (!rpmverp)
+      {
+	fprintf (stderr, "dlsym (\"RPMVERSION\"): %s\n", dlerror ());
+	return 1;
+      }
+    fprintf (stderr, "RPMVERSION is: \"");
+    fprintf (stderr, "%s\"\n", *rpmverp);
+
+    /* Try to find the specific librpm version only for "librpm.so" as we do
+       not know how to assemble the version string otherwise.  */
+
+    if (strcmp ("librpm.so", $LIBRPM_STRING) != 0)
+      {
+	fprintf (f, "%s\n", $LIBRPM_STRING);
+	return 0;
+      }
+    else
+      {
+	char *h2_name;
+	void *h2;
+	int major, minor;
+
+	if (sscanf (*rpmverp, "%d.%d", &major, &minor) != 2)
+	  {
+	    fprintf (stderr, "Unable to parse RPMVERSION.\n");
+	    fprintf (f, "%s\n", $LIBRPM_STRING);
+	    return 0;
+	  }
+	/* Avoid the square brackets by malloc.  */
+	h2_name = malloc (64);
+	sprintf (h2_name, "librpm-%d.%d.so", major, minor);
+	h2 = dlopen (h2_name, RTLD_LAZY);
+	if (!h2)
+	  {
+	    fprintf (stderr, "dlopen (\"%s\"): %s\n", h2_name, dlerror ());
+	    fprintf (f, "%s\n", $LIBRPM_STRING);
+	    return 0;
+	  }
+	if (h2 != h)
+	  {
+	    fprintf (stderr, "dlopen of \"%s\" and \"%s\" are different.\n",
+		     $LIBRPM_STRING, h2_name);
+	    fprintf (f, "%s\n", $LIBRPM_STRING);
+	    return 0;
+	  }
+	/* Found the valid .so name with a specific version.  */
+	fprintf (f, "%s\n", h2_name);
+	return 0;
+      }
+  ]]), [
+    DLOPEN_LIBRPM="`cat conftest.out`"
+    if test "x$DLOPEN_LIBRPM" != "x"; then
+      HAVE_DLOPEN_LIBRPM=true
+      AC_MSG_RESULT($DLOPEN_LIBRPM)
+    fi
+  ])
+  rm -f conftest.out
+
+  m4_define([CHECK_LIBRPM_COMPAT], [
+    AC_MSG_CHECKING([rpm library API compatibility])
+    # The compilation requires -Werror to verify anything.
+    save_CFLAGS="$CFLAGS"
+    CFLAGS="$CFLAGS -Werror"
+    AC_COMPILE_IFELSE(AC_LANG_PROGRAM([[
+/* Duplicate here the declarations to verify they match "elfread.c".  */
+#include <rpm/rpmlib.h>
+#include <rpm/rpmts.h>
+#include <rpm/rpmdb.h>
+#include <rpm/header.h>
+extern char * headerFormat(Header h, const char * fmt, errmsg_t * errmsg);
+extern int rpmReadConfigFiles(const char * file, const char * target);
+extern rpmdbMatchIterator rpmdbFreeIterator(rpmdbMatchIterator mi);
+extern Header rpmdbNextIterator(rpmdbMatchIterator mi);
+extern rpmts rpmtsCreate(void);
+extern rpmts rpmtsFree(rpmts ts);
+extern rpmdbMatchIterator rpmtsInitIterator(const rpmts ts, rpmTag rpmtag,
+					    const void * keyp, size_t keylen);
+    ]]), [
+      LIBRPM_COMPAT=true
+      AC_MSG_RESULT(yes)
+    ], [
+      LIBRPM_COMPAT=false
+      AC_MSG_RESULT(no)
+    ])
+    CFLAGS="$save_CFLAGS"
+  ])
+
+  if $HAVE_DLOPEN_LIBRPM; then
+    CHECK_LIBRPM_COMPAT
+    if ! $LIBRPM_COMPAT; then
+      HAVE_DLOPEN_LIBRPM=false
+    fi
+  fi
+
+  if $HAVE_DLOPEN_LIBRPM; then
+    DLOPEN_LIBRPM_STRING='"'"$DLOPEN_LIBRPM"'"'
+    AC_DEFINE_UNQUOTED(DLOPEN_LIBRPM, $DLOPEN_LIBRPM_STRING, [librpm version specific library name to dlopen.])
+    AC_DEFINE(HAVE_LIBRPM, 1, [Define if librpm library is being used.])
+  else
+    AC_MSG_RESULT(no)
+    LIBS="$save_LIBS"
+    if $DLOPEN_REQUIRE; then
+      AC_MSG_ERROR([Specific name $LIBRPM was requested but it could not be opened.])
+    fi
+    PKG_CHECK_MODULES(RPM, rpm, [HAVE_LIBRPM=true], [HAVE_LIBRPM=false])
+
+    if $HAVE_LIBRPM; then
+      CHECK_LIBRPM_COMPAT
+      if ! $LIBRPM_COMPAT; then
+	HAVE_LIBRPM=false
+	RPM_PKG_ERRORS="Found $LIBRPM API is incompatibile with this GDB"
+      fi
+    fi
+
+    if $HAVE_LIBRPM; then
+      AC_DEFINE(HAVE_LIBRPM, 1, [Define if librpm library is being used.])
+      CFLAGS="$CFLAGS $RPM_CFLAGS"
+      LIBS="$LIBS $RPM_LIBS"
+    else
+      if $RPM_REQUIRE; then
+	AC_MSG_ERROR($RPM_PKG_ERRORS)
+      else
+	AC_MSG_WARN($RPM_PKG_ERRORS)
+      fi
+    fi
+  fi
+fi
+
 AC_CONFIG_SUBDIRS(testsuite)

 # Check whether to support alternative target configurations
diff -rup gdb-7.4ori//gdb/corelow.c gdb-7.4/gdb/corelow.c
--- gdb-7.4ori//gdb/corelow.c	2012-01-06 05:43:06.000000000 +0100
+++ gdb-7.4/gdb/corelow.c	2012-05-10 11:26:26.319643428 +0200
@@ -47,7 +47,9 @@
 #include "progspace.h"
 #include "objfiles.h"
 #include "wrapper.h"
-
+#include "auxv.h"
+#include "elf/common.h"
+#include "gdbcmd.h"
 
 #ifndef O_LARGEFILE
 #define O_LARGEFILE 0
@@ -278,6 +280,52 @@ add_to_thread_list (bfd *abfd, asection
     inferior_ptid = ptid;			/* Yes, make it current.  */
 }
 
+static int build_id_core_loads = 1;
+
+static void
+build_id_locate_exec (int from_tty)
+{
+  CORE_ADDR at_entry;
+  struct build_id *build_id;
+  char *exec_filename, *debug_filename;
+  char *build_id_filename;
+  struct cleanup *back_to;
+
+  if (exec_bfd != NULL || symfile_objfile != NULL)
+    return;
+
+  if (target_auxv_search (&current_target, AT_ENTRY, &at_entry) <= 0)
+    return;
+
+  build_id = build_id_addr_get (at_entry);
+  if (build_id == NULL)
+    return;
+
+  /* SYMFILE_OBJFILE should refer to the main executable (not only to its
+     separate debug info file).  gcc44+ keeps .eh_frame only in the main
+     executable without its duplicate .debug_frame in the separate debug info
+     file - such .eh_frame would not be found if SYMFILE_OBJFILE would refer
+     directly to the separate debug info file.  */
+
+  exec_filename = build_id_to_filename (build_id, &build_id_filename, 0);
+  back_to = make_cleanup (xfree, build_id_filename);
+
+  if (exec_filename != NULL)
+    {
+      make_cleanup (xfree, exec_filename);
+      exec_file_attach (exec_filename, from_tty);
+      symbol_file_add_main (exec_filename, from_tty);
+      if (symfile_objfile != NULL)
+        symfile_objfile->flags |= OBJF_BUILD_ID_CORE_LOADED;
+    }
+  else
+    debug_print_missing (BUILD_ID_MAIN_EXECUTABLE_FILENAME, build_id_filename);
+
+  do_cleanups (back_to);
+
+  /* No automatic SOLIB_ADD as the libraries would get read twice.  */
+}
+
 /* This routine opens and sets up the core file bfd.  */
 
 static void
@@ -379,6 +427,12 @@ core_open (char *filename, int from_tty)
   push_target (&core_ops);
   discard_cleanups (old_chain);
 
+  /* Find the build_id identifiers.  If it gets executed after
+     POST_CREATE_INFERIOR we would clash with asking to discard the already
+     loaded VDSO symbols.  */
+  if (build_id_core_loads != 0)
+    build_id_locate_exec (from_tty);
+
   /* Do this before acknowledging the inferior, so if
      post_create_inferior throws (can happen easilly if you're loading
      a core file with the wrong exec), we aren't left with threads
@@ -932,4 +986,11 @@ _initialize_corelow (void)
   init_core_ops ();
 
   add_target (&core_ops);
+
+  add_setshow_boolean_cmd ("build-id-core-loads", class_files,
+			   &build_id_core_loads, _("\
+Set whether CORE-FILE loads the build-id associated files automatically."), _("\
+Show whether CORE-FILE loads the build-id associated files automatically.."),
+			   NULL, NULL, NULL,
+			   &setlist, &showlist);
 }
diff -rup gdb-7.4ori//gdb/doc/gdb.texinfo gdb-7.4/gdb/doc/gdb.texinfo
--- gdb-7.4ori//gdb/doc/gdb.texinfo	2012-01-06 05:43:35.000000000 +0100
+++ gdb-7.4/gdb/doc/gdb.texinfo	2012-05-10 11:10:37.455644929 +0200
@@ -15872,6 +15872,27 @@ information files.
 
 @end table
 
+You can also adjust the current verbosity of the @dfn{build id} locating.
+
+@table @code
+
+@kindex set build-id-verbose
+@item set build-id-verbose 0
+No additional messages are printed.
+
+@item set build-id-verbose 1
+Missing separate debug filenames are printed.
+
+@item set build-id-verbose 2
+Missing separate debug filenames are printed and also all the parsing of the
+binaries to find their @dfn{build id} content is printed.
+
+@kindex show build-id-verbose
+@item show build-id-verbose
+Show the current verbosity value for the @dfn{build id} content locating.
+
+@end table
+
 @cindex @code{.gnu_debuglink} sections
 @cindex debug link sections
 A debug link is a special section of the executable file named
diff -rup gdb-7.4ori//gdb/elfread.c gdb-7.4/gdb/elfread.c
--- gdb-7.4ori//gdb/elfread.c	2012-01-06 05:43:11.000000000 +0100
+++ gdb-7.4/gdb/elfread.c	2012-05-10 11:27:18.443643345 +0200
@@ -41,6 +41,12 @@
 #include "infcall.h"
 #include "gdbthread.h"
 #include "regcache.h"
+#include "libbfd.h"
+#include "gdbcore.h"
+#include "gdbcmd.h"
+#include "observer.h"
+#include "elf/external.h"
+#include <sys/stat.h>
 
 extern void _initialize_elfread (void);
 
@@ -1042,16 +1048,65 @@ elf_gnu_ifunc_resolver_return_stop (stru
   update_breakpoint_locations (b, sals, sals_end);
 }
 
+#define BUILD_ID_VERBOSE_NONE 0
+#define BUILD_ID_VERBOSE_FILENAMES 1
+#define BUILD_ID_VERBOSE_BINARY_PARSE 2
+static int build_id_verbose = BUILD_ID_VERBOSE_FILENAMES;
+static void
+show_build_id_verbose (struct ui_file *file, int from_tty,
+		       struct cmd_list_element *c, const char *value)
+{
+  fprintf_filtered (file, _("Verbosity level of the build-id locator is %s.\n"),
+		    value);
+}
+
 struct build_id
   {
     size_t size;
     gdb_byte data[1];
   };
 
-/* Locate NT_GNU_BUILD_ID from ABFD and return its content.  */
+/* Locate NT_GNU_BUILD_ID and return its matching debug filename.
+   FIXME: NOTE decoding should be unified with the BFD core notes decoding.  */
+
+struct build_id *
+build_id_buf_get (bfd *templ, gdb_byte *buf, bfd_size_type size)
+{
+  bfd_byte *p;
+
+  p = buf;
+  while (p < buf + size)
+    {
+      /* FIXME: bad alignment assumption.  */
+      Elf_External_Note *xnp = (Elf_External_Note *) p;
+      size_t namesz = H_GET_32 (templ, xnp->namesz);
+      size_t descsz = H_GET_32 (templ, xnp->descsz);
+      bfd_byte *descdata = xnp->name + BFD_ALIGN (namesz, 4);
+
+      if (H_GET_32 (templ, xnp->type) == NT_GNU_BUILD_ID
+	  && namesz == sizeof "GNU"
+	  && memcmp (xnp->name, "GNU", sizeof "GNU") == 0)
+	{
+	  size_t size = descsz;
+	  gdb_byte *data = (void *) descdata;
+	  struct build_id *retval;
+
+	  retval = xmalloc (sizeof *retval - 1 + size);
+	  retval->size = size;
+	  memcpy (retval->data, data, size);
+
+	  return retval;
+	}
+      p = descdata + BFD_ALIGN (descsz, 4);
+    }
+  return NULL;
+}
+
+/* Separate debuginfo files have corrupted PHDR but SHDR is correct there.
+   Locate NT_GNU_BUILD_ID from ABFD and return its content.  */
 
 static struct build_id *
-build_id_bfd_get (bfd *abfd)
+build_id_bfd_shdr_get (bfd *abfd)
 {
   struct build_id *retval;
 
@@ -1067,6 +1122,348 @@ build_id_bfd_get (bfd *abfd)
   return retval;
 }
 
+/* Core files may have missing (corrupt) SHDR but PDHR is correct there.
+   bfd_elf_bfd_from_remote_memory () has too much overhead by
+   allocating/reading all the available ELF PT_LOADs.  */
+
+static struct build_id *
+build_id_phdr_get (bfd *templ, bfd_vma loadbase, unsigned e_phnum,
+		   Elf_Internal_Phdr *i_phdr)
+{
+  int i;
+  struct build_id *retval = NULL;
+
+  for (i = 0; i < e_phnum; i++)
+    if (i_phdr[i].p_type == PT_NOTE && i_phdr[i].p_filesz > 0)
+      {
+	Elf_Internal_Phdr *hdr = &i_phdr[i];
+	gdb_byte *buf;
+	int err;
+
+	buf = xmalloc (hdr->p_filesz);
+	err = target_read_memory (loadbase + i_phdr[i].p_vaddr, buf,
+				  hdr->p_filesz);
+	if (err == 0)
+	  retval = build_id_buf_get (templ, buf, hdr->p_filesz);
+	else
+	  retval = NULL;
+	xfree (buf);
+	if (retval != NULL)
+	  break;
+      }
+  return retval;
+}
+
+/* First we validate the file by reading in the ELF header and checking
+   the magic number.  */
+
+static inline bfd_boolean
+elf_file_p (Elf64_External_Ehdr *x_ehdrp64)
+{
+  gdb_assert (sizeof (Elf64_External_Ehdr) >= sizeof (Elf32_External_Ehdr));
+  gdb_assert (offsetof (Elf64_External_Ehdr, e_ident)
+	      == offsetof (Elf32_External_Ehdr, e_ident));
+  gdb_assert (sizeof (((Elf64_External_Ehdr *) 0)->e_ident)
+	      == sizeof (((Elf32_External_Ehdr *) 0)->e_ident));
+
+  return ((x_ehdrp64->e_ident[EI_MAG0] == ELFMAG0)
+	  && (x_ehdrp64->e_ident[EI_MAG1] == ELFMAG1)
+	  && (x_ehdrp64->e_ident[EI_MAG2] == ELFMAG2)
+	  && (x_ehdrp64->e_ident[EI_MAG3] == ELFMAG3));
+}
+
+/* Translate an ELF file header in external format into an ELF file header in
+   internal format.  */
+
+#define H_GET_WORD(bfd, ptr) (is64 ? H_GET_64 (bfd, (ptr))		\
+				   : H_GET_32 (bfd, (ptr)))
+#define H_GET_SIGNED_WORD(bfd, ptr) (is64 ? H_GET_S64 (bfd, (ptr))	\
+					  : H_GET_S32 (bfd, (ptr)))
+
+static void
+elf_swap_ehdr_in (bfd *abfd,
+		  const Elf64_External_Ehdr *src64,
+		  Elf_Internal_Ehdr *dst)
+{
+  int is64 = bfd_get_arch_size (abfd) == 64;
+#define SRC(field) (is64 ? src64->field \
+			 : ((const Elf32_External_Ehdr *) src64)->field)
+
+  int signed_vma = get_elf_backend_data (abfd)->sign_extend_vma;
+  memcpy (dst->e_ident, SRC (e_ident), EI_NIDENT);
+  dst->e_type = H_GET_16 (abfd, SRC (e_type));
+  dst->e_machine = H_GET_16 (abfd, SRC (e_machine));
+  dst->e_version = H_GET_32 (abfd, SRC (e_version));
+  if (signed_vma)
+    dst->e_entry = H_GET_SIGNED_WORD (abfd, SRC (e_entry));
+  else
+    dst->e_entry = H_GET_WORD (abfd, SRC (e_entry));
+  dst->e_phoff = H_GET_WORD (abfd, SRC (e_phoff));
+  dst->e_shoff = H_GET_WORD (abfd, SRC (e_shoff));
+  dst->e_flags = H_GET_32 (abfd, SRC (e_flags));
+  dst->e_ehsize = H_GET_16 (abfd, SRC (e_ehsize));
+  dst->e_phentsize = H_GET_16 (abfd, SRC (e_phentsize));
+  dst->e_phnum = H_GET_16 (abfd, SRC (e_phnum));
+  dst->e_shentsize = H_GET_16 (abfd, SRC (e_shentsize));
+  dst->e_shnum = H_GET_16 (abfd, SRC (e_shnum));
+  dst->e_shstrndx = H_GET_16 (abfd, SRC (e_shstrndx));
+
+#undef SRC
+}
+
+/* Translate an ELF program header table entry in external format into an
+   ELF program header table entry in internal format.  */
+
+void
+elf_swap_phdr_in (bfd *abfd,
+		  const Elf64_External_Phdr *src64,
+		  Elf_Internal_Phdr *dst)
+{
+  int is64 = bfd_get_arch_size (abfd) == 64;
+#define SRC(field) (is64 ? src64->field					\
+			 : ((const Elf32_External_Phdr *) src64)->field)
+
+  int signed_vma = get_elf_backend_data (abfd)->sign_extend_vma;
+
+  dst->p_type = H_GET_32 (abfd, SRC (p_type));
+  dst->p_flags = H_GET_32 (abfd, SRC (p_flags));
+  dst->p_offset = H_GET_WORD (abfd, SRC (p_offset));
+  if (signed_vma)
+    {
+      dst->p_vaddr = H_GET_SIGNED_WORD (abfd, SRC (p_vaddr));
+      dst->p_paddr = H_GET_SIGNED_WORD (abfd, SRC (p_paddr));
+    }
+  else
+    {
+      dst->p_vaddr = H_GET_WORD (abfd, SRC (p_vaddr));
+      dst->p_paddr = H_GET_WORD (abfd, SRC (p_paddr));
+    }
+  dst->p_filesz = H_GET_WORD (abfd, SRC (p_filesz));
+  dst->p_memsz = H_GET_WORD (abfd, SRC (p_memsz));
+  dst->p_align = H_GET_WORD (abfd, SRC (p_align));
+
+#undef SRC
+}
+
+#undef H_GET_SIGNED_WORD
+#undef H_GET_WORD
+
+static Elf_Internal_Phdr *
+elf_get_phdr (bfd *templ, bfd_vma ehdr_vma, unsigned *e_phnum_pointer,
+              bfd_vma *loadbase_pointer)
+{
+  /* sizeof (Elf64_External_Ehdr) >= sizeof (Elf32_External_Ehdr)  */
+  Elf64_External_Ehdr x_ehdr64;	/* Elf file header, external form */
+  Elf_Internal_Ehdr i_ehdr;	/* Elf file header, internal form */
+  bfd_size_type x_phdrs_size;
+  gdb_byte *x_phdrs_ptr;
+  Elf_Internal_Phdr *i_phdrs;
+  int err;
+  unsigned int i;
+  bfd_vma loadbase;
+  int loadbase_set;
+
+  gdb_assert (templ != NULL);
+  gdb_assert (sizeof (Elf64_External_Ehdr) >= sizeof (Elf32_External_Ehdr));
+
+  /* Read in the ELF header in external format.  */
+  err = target_read_memory (ehdr_vma, (bfd_byte *) &x_ehdr64, sizeof x_ehdr64);
+  if (err)
+    {
+      if (build_id_verbose >= BUILD_ID_VERBOSE_BINARY_PARSE)
+        warning (_("build-id: Error reading ELF header at address 0x%lx"),
+		 (unsigned long) ehdr_vma);
+      return NULL;
+    }
+
+  /* Now check to see if we have a valid ELF file, and one that BFD can
+     make use of.  The magic number must match, the address size ('class')
+     and byte-swapping must match our XVEC entry.  */
+
+  if (! elf_file_p (&x_ehdr64)
+      || x_ehdr64.e_ident[EI_VERSION] != EV_CURRENT
+      || !((bfd_get_arch_size (templ) == 64
+            && x_ehdr64.e_ident[EI_CLASS] == ELFCLASS64)
+           || (bfd_get_arch_size (templ) == 32
+	       && x_ehdr64.e_ident[EI_CLASS] == ELFCLASS32)))
+    {
+      if (build_id_verbose >= BUILD_ID_VERBOSE_BINARY_PARSE)
+        warning (_("build-id: Unrecognized ELF header at address 0x%lx"),
+		 (unsigned long) ehdr_vma);
+      return NULL;
+    }
+
+  /* Check that file's byte order matches xvec's */
+  switch (x_ehdr64.e_ident[EI_DATA])
+    {
+    case ELFDATA2MSB:		/* Big-endian */
+      if (! bfd_header_big_endian (templ))
+	{
+	  if (build_id_verbose >= BUILD_ID_VERBOSE_BINARY_PARSE)
+	    warning (_("build-id: Unrecognized "
+		       "big-endian ELF header at address 0x%lx"),
+		     (unsigned long) ehdr_vma);
+	  return NULL;
+	}
+      break;
+    case ELFDATA2LSB:		/* Little-endian */
+      if (! bfd_header_little_endian (templ))
+	{
+	  if (build_id_verbose >= BUILD_ID_VERBOSE_BINARY_PARSE)
+	    warning (_("build-id: Unrecognized "
+		       "little-endian ELF header at address 0x%lx"),
+		     (unsigned long) ehdr_vma);
+	  return NULL;
+	}
+      break;
+    case ELFDATANONE:		/* No data encoding specified */
+    default:			/* Unknown data encoding specified */
+      if (build_id_verbose >= BUILD_ID_VERBOSE_BINARY_PARSE)
+	warning (_("build-id: Unrecognized "
+		   "ELF header endianity at address 0x%lx"),
+		 (unsigned long) ehdr_vma);
+      return NULL;
+    }
+
+  elf_swap_ehdr_in (templ, &x_ehdr64, &i_ehdr);
+
+  /* The file header tells where to find the program headers.
+     These are what we use to actually choose what to read.  */
+
+  if (i_ehdr.e_phentsize != (bfd_get_arch_size (templ) == 64
+                             ? sizeof (Elf64_External_Phdr)
+			     : sizeof (Elf32_External_Phdr))
+      || i_ehdr.e_phnum == 0)
+    {
+      if (build_id_verbose >= BUILD_ID_VERBOSE_BINARY_PARSE)
+	warning (_("build-id: Invalid ELF program headers from the ELF header "
+		   "at address 0x%lx"), (unsigned long) ehdr_vma);
+      return NULL;
+    }
+
+  x_phdrs_size = (bfd_get_arch_size (templ) == 64 ? sizeof (Elf64_External_Phdr)
+						: sizeof (Elf32_External_Phdr));
+
+  i_phdrs = xmalloc (i_ehdr.e_phnum * (sizeof *i_phdrs + x_phdrs_size));
+  x_phdrs_ptr = (void *) &i_phdrs[i_ehdr.e_phnum];
+  err = target_read_memory (ehdr_vma + i_ehdr.e_phoff, (bfd_byte *) x_phdrs_ptr,
+			    i_ehdr.e_phnum * x_phdrs_size);
+  if (err)
+    {
+      free (i_phdrs);
+      if (build_id_verbose >= BUILD_ID_VERBOSE_BINARY_PARSE)
+        warning (_("build-id: Error reading "
+		   "ELF program headers at address 0x%lx"),
+		 (unsigned long) (ehdr_vma + i_ehdr.e_phoff));
+      return NULL;
+    }
+
+  loadbase = ehdr_vma;
+  loadbase_set = 0;
+  for (i = 0; i < i_ehdr.e_phnum; ++i)
+    {
+      elf_swap_phdr_in (templ, (Elf64_External_Phdr *)
+			       (x_phdrs_ptr + i * x_phdrs_size), &i_phdrs[i]);
+      /* IA-64 vDSO may have two mappings for one segment, where one mapping
+	 is executable only, and one is read only.  We must not use the
+	 executable one (PF_R is the first one, PF_X the second one).  */
+      if (i_phdrs[i].p_type == PT_LOAD && (i_phdrs[i].p_flags & PF_R))
+	{
+	  /* Only the first PT_LOAD segment indicates the file bias.
+	     Next segments may have P_VADDR arbitrarily higher.
+	     If the first segment has P_VADDR zero any next segment must not
+	     confuse us, the first one sets LOADBASE certainly enough.  */
+	  if (!loadbase_set && i_phdrs[i].p_offset == 0)
+	    {
+	      loadbase = ehdr_vma - i_phdrs[i].p_vaddr;
+	      loadbase_set = 1;
+	    }
+	}
+    }
+
+  if (build_id_verbose >= BUILD_ID_VERBOSE_BINARY_PARSE)
+    warning (_("build-id: Found ELF header at address 0x%lx, loadbase 0x%lx"),
+	     (unsigned long) ehdr_vma, (unsigned long) loadbase);
+
+  *e_phnum_pointer = i_ehdr.e_phnum;
+  *loadbase_pointer = loadbase;
+  return i_phdrs;
+}
+
+/* BUILD_ID_ADDR_GET gets ADDR located somewhere in the object.
+   Find the first section before ADDR containing an ELF header.
+   We rely on the fact the sections from multiple files do not mix.
+   FIXME: We should check ADDR is contained _inside_ the section with possibly
+   missing content (P_FILESZ < P_MEMSZ).  These omitted sections are currently
+   hidden by _BFD_ELF_MAKE_SECTION_FROM_PHDR.  */
+
+static CORE_ADDR build_id_addr;
+struct build_id_addr_sect
+  {
+    struct build_id_addr_sect *next;
+    asection *sect;
+  };
+static struct build_id_addr_sect *build_id_addr_sect;
+
+static void build_id_addr_candidate (bfd *abfd, asection *sect, void *obj)
+{
+  if (build_id_addr >= bfd_section_vma (abfd, sect))
+    {
+      struct build_id_addr_sect *candidate;
+
+      candidate = xmalloc (sizeof *candidate);
+      candidate->next = build_id_addr_sect;
+      build_id_addr_sect = candidate;
+      candidate->sect = sect;
+    }
+}
+
+struct build_id *
+build_id_addr_get (CORE_ADDR addr)
+{
+  struct build_id_addr_sect *candidate;
+  struct build_id *retval = NULL;
+  Elf_Internal_Phdr *i_phdr = NULL;
+  bfd_vma loadbase = 0;
+  unsigned e_phnum = 0;
+
+  if (core_bfd == NULL)
+    return NULL;
+
+  build_id_addr = addr;
+  gdb_assert (build_id_addr_sect == NULL);
+  bfd_map_over_sections (core_bfd, build_id_addr_candidate, NULL);
+
+  /* Sections are sorted in the high-to-low VMAs order.
+     Stop the search on the first ELF header we find.
+     Do not continue the search even if it does not contain NT_GNU_BUILD_ID.  */
+
+  for (candidate = build_id_addr_sect; candidate != NULL;
+       candidate = candidate->next)
+    {
+      i_phdr = elf_get_phdr (core_bfd,
+			     bfd_section_vma (core_bfd, candidate->sect),
+			     &e_phnum, &loadbase);
+      if (i_phdr != NULL)
+	break;
+    }
+
+  if (i_phdr != NULL)
+    {
+      retval = build_id_phdr_get (core_bfd, loadbase, e_phnum, i_phdr);
+      xfree (i_phdr);
+    }
+
+  while (build_id_addr_sect != NULL)
+    {
+      candidate = build_id_addr_sect;
+      build_id_addr_sect = candidate->next;
+      xfree (candidate);
+    }
+
+  return retval;
+}
+
 /* Return if FILENAME has NT_GNU_BUILD_ID matching the CHECK value.  */
 
 static int
@@ -1081,7 +1478,7 @@ build_id_verify (const char *filename, s
   if (abfd == NULL)
     return 0;
 
-  found = build_id_bfd_get (abfd);
+  found = build_id_bfd_shdr_get (abfd);
 
   if (found == NULL)
     warning (_("File \"%s\" has no build-id, file skipped"), filename);
@@ -1099,14 +1496,15 @@ build_id_verify (const char *filename, s
   return retval;
 }
 
-static char *
-build_id_to_debug_filename (struct build_id *build_id)
+char *
+build_id_to_filename (struct build_id *build_id, char **link_return,
+		      int add_debug_suffix)
 {
   char *link, *debugdir, *retval = NULL;
+  char *link_all = NULL;
 
   /* DEBUG_FILE_DIRECTORY/.build-id/ab/cdef */
-  link = alloca (strlen (debug_file_directory) + (sizeof "/.build-id/" - 1) + 1
-		 + 2 * build_id->size + (sizeof ".debug" - 1) + 1);
+  link = xmalloc (strlen (debug_file_directory) + 2 * build_id->size + 50);
 
   /* Keep backward compatibility so that DEBUG_FILE_DIRECTORY being "" will
      cause "/.build-id/..." lookups.  */
@@ -1117,6 +1515,8 @@ build_id_to_debug_filename (struct build
       char *s, *debugdir_end;
       gdb_byte *data = build_id->data;
       size_t size = build_id->size;
+      unsigned seqno;
+      struct stat statbuf_trash;
 
       while (*debugdir == DIRNAME_SEPARATOR)
 	debugdir++;
@@ -1137,39 +1537,637 @@ build_id_to_debug_filename (struct build
 	*s++ = '/';
       while (size-- > 0)
 	s += sprintf (s, "%02x", (unsigned) *data++);
-      strcpy (s, ".debug");
-
-      /* lrealpath() is expensive even for the usually non-existent files.  */
-      if (access (link, F_OK) == 0)
-	retval = lrealpath (link);
 
-      if (retval != NULL && !build_id_verify (retval, build_id))
+      for (seqno = 0;; seqno++)
 	{
-	  xfree (retval);
-	  retval = NULL;
+	  char *s2;
+
+	  if (seqno)
+	    {
+	      /* There can be multiple build-id symlinks pointing to real files
+		 with the same build-id (such as hard links).  Some of the real
+		 files may not be installed.  */
+
+	      s2 = s + sprintf (s, ".%u", seqno);
+	    }
+	  else
+	    s2 = s;
+
+	  if (add_debug_suffix)
+	    strcpy (s2, ".debug");
+	  else
+	    *s2 = 0;
+
+	  /* `access' automatically dereferences LINK.  */
+	  if (lstat (link, &statbuf_trash) != 0)
+	    {
+	      /* Stop increasing SEQNO.  */
+	      break;
+	    }
+
+	  retval = lrealpath (link);
+
+	  if (retval != NULL && !build_id_verify (retval, build_id))
+	    {
+	      xfree (retval);
+	      retval = NULL;
+	    }
+
+	  if (retval)
+	    break;
 	}
 
       if (retval != NULL)
-	break;
+	{
+	  /* LINK_ALL is not used below in this non-NULL RETVAL case.  */
+	  break;
+	}
+
+	if (link_all == NULL)
+	  link_all = xstrdup (link);
+	else
+	  {
+	    size_t len_orig = strlen (link_all);
+
+	    link_all = xrealloc (link_all, len_orig + 1 + strlen (link) + 1);
+
+	    /* Use whitespace instead of DIRNAME_SEPARATOR to be compatible with
+	       its possible use as an argument for installation command.  */
+	    link_all[len_orig] = ' ';
+
+	    strcpy (&link_all[len_orig + 1], link);
+	  }
 
       debugdir = debugdir_end;
     }
   while (*debugdir != 0);
 
+  if (link_return != NULL)
+    {
+      if (retval != NULL)
+       {
+         *link_return = link;
+         link = NULL;
+       }
+      else
+       {
+         *link_return = link_all;
+         link_all = NULL;
+       }
+    }
+  xfree (link);
+  xfree (link_all);
+
+  return retval;
+}
+
+#ifdef HAVE_LIBRPM
+
+#include <rpm/rpmlib.h>
+#include <rpm/rpmts.h>
+#include <rpm/rpmdb.h>
+#include <rpm/header.h>
+#ifdef DLOPEN_LIBRPM
+#include <dlfcn.h>
+#endif
+
+/* Workarodun https://bugzilla.redhat.com/show_bug.cgi?id=643031
+   librpm must not exit() an application on SIGINT
+
+   Enable or disable a signal handler.  SIGNUM: signal to enable (or disable
+   if negative).  HANDLER: sa_sigaction handler (or NULL to use
+   rpmsqHandler()).  Returns: no. of refs, -1 on error.  */
+int
+rpmsqEnable (int signum, /* rpmsqAction_t handler */ void *handler)
+{
+  return 0;
+}
+
+/* This MISSING_RPM_HASH tracker is used to collect all the missing rpm files
+   and avoid their duplicities during a single inferior run.  */
+
+static struct htab *missing_rpm_hash;
+
+/* This MISSING_RPM_LIST tracker is used to collect and print as a single line
+   all the rpms right before the nearest GDB prompt.  It gets cleared after
+   each such print (it is questionable if we should clear it after the print).
+   */
+
+struct missing_rpm
+  {
+    struct missing_rpm *next;
+    char rpm[1];
+  };
+static struct missing_rpm *missing_rpm_list;
+static int missing_rpm_list_entries;
+
+/* Returns the count of newly added rpms.  */
+
+static int
+missing_rpm_enlist (const char *filename)
+{
+  static int rpm_init_done = 0;
+  rpmts ts;
+  rpmdbMatchIterator mi;
+  int count = 0;
+
+#ifdef DLOPEN_LIBRPM
+  /* Duplicate here the declarations to verify they match.  The same sanity
+     check is present also in `configure.ac'.  */
+  extern char * headerFormat(Header h, const char * fmt, errmsg_t * errmsg);
+  static char *(*headerFormat_p) (Header h, const char * fmt, errmsg_t *errmsg);
+  extern int rpmReadConfigFiles(const char * file, const char * target);
+  static int (*rpmReadConfigFiles_p) (const char * file, const char * target);
+  extern rpmdbMatchIterator rpmdbFreeIterator(rpmdbMatchIterator mi);
+  static rpmdbMatchIterator (*rpmdbFreeIterator_p) (rpmdbMatchIterator mi);
+  extern Header rpmdbNextIterator(rpmdbMatchIterator mi);
+  static Header (*rpmdbNextIterator_p) (rpmdbMatchIterator mi);
+  extern rpmts rpmtsCreate(void);
+  static rpmts (*rpmtsCreate_p) (void);
+  extern rpmts rpmtsFree(rpmts ts);
+  static rpmts (*rpmtsFree_p) (rpmts ts);
+  extern rpmdbMatchIterator rpmtsInitIterator(const rpmts ts, rpmTag rpmtag,
+                                              const void * keyp, size_t keylen);
+  static rpmdbMatchIterator (*rpmtsInitIterator_p) (const rpmts ts,
+						    rpmTag rpmtag,
+						    const void *keyp,
+						    size_t keylen);
+#else	/* !DLOPEN_LIBRPM */
+# define headerFormat_p headerFormat
+# define rpmReadConfigFiles_p rpmReadConfigFiles
+# define rpmdbFreeIterator_p rpmdbFreeIterator
+# define rpmdbNextIterator_p rpmdbNextIterator
+# define rpmtsCreate_p rpmtsCreate
+# define rpmtsFree_p rpmtsFree
+# define rpmtsInitIterator_p rpmtsInitIterator
+#endif	/* !DLOPEN_LIBRPM */
+
+  gdb_assert (filename != NULL);
+
+  if (strcmp (filename, BUILD_ID_MAIN_EXECUTABLE_FILENAME) == 0)
+    return 0;
+
+  if (filename[0] != '/')
+    {
+      warning (_("Ignoring non-absolute filename: <%s>"), filename);
+      return 0;
+    }
+
+  if (!rpm_init_done)
+    {
+      static int init_tried;
+
+      /* Already failed the initialization before?  */
+      if (init_tried)
+      	return 0;
+      init_tried = 1;
+
+#ifdef DLOPEN_LIBRPM
+      {
+	void *h;
+
+	h = dlopen (DLOPEN_LIBRPM, RTLD_LAZY);
+	if (!h)
+	  {
+	    warning (_("Unable to open \"%s\" (%s), "
+		      "missing debuginfos notifications will not be displayed"),
+		     DLOPEN_LIBRPM, dlerror ());
+	    return 0;
+	  }
+
+	if (!((headerFormat_p = dlsym (h, "headerFormat"))
+	      && (rpmReadConfigFiles_p = dlsym (h, "rpmReadConfigFiles"))
+	      && (rpmdbFreeIterator_p = dlsym (h, "rpmdbFreeIterator"))
+	      && (rpmdbNextIterator_p = dlsym (h, "rpmdbNextIterator"))
+	      && (rpmtsCreate_p = dlsym (h, "rpmtsCreate"))
+	      && (rpmtsFree_p = dlsym (h, "rpmtsFree"))
+	      && (rpmtsInitIterator_p = dlsym (h, "rpmtsInitIterator"))))
+	  {
+	    warning (_("Opened library \"%s\" is incompatible (%s), "
+		      "missing debuginfos notifications will not be displayed"),
+		     DLOPEN_LIBRPM, dlerror ());
+	    if (dlclose (h))
+	      warning (_("Error closing library \"%s\": %s\n"), DLOPEN_LIBRPM,
+		       dlerror ());
+	    return 0;
+	  }
+      }
+#endif	/* DLOPEN_LIBRPM */
+
+      if (rpmReadConfigFiles_p (NULL, NULL) != 0)
+	{
+	  warning (_("Error reading the rpm configuration files"));
+	  return 0;
+	}
+
+      rpm_init_done = 1;
+    }
+
+  ts = rpmtsCreate_p ();
+
+  mi = rpmtsInitIterator_p (ts, RPMTAG_BASENAMES, filename, 0);
+  if (mi != NULL)
+    {
+      for (;;)
+	{
+	  Header h;
+	  char *debuginfo, **slot, *s, *s2;
+	  errmsg_t err;
+	  size_t srcrpmlen = sizeof (".src.rpm") - 1;
+	  size_t debuginfolen = sizeof ("-debuginfo") - 1;
+	  rpmdbMatchIterator mi_debuginfo;
+
+	  h = rpmdbNextIterator_p (mi);
+	  if (h == NULL)
+	    break;
+
+	  /* Verify the debuginfo file is not already installed.  */
+
+	  debuginfo = headerFormat_p (h, "%{sourcerpm}-debuginfo.%{arch}",
+				      &err);
+	  if (!debuginfo)
+	    {
+	      warning (_("Error querying the rpm file `%s': %s"), filename,
+	               err);
+	      continue;
+	    }
+	  /* s = `.src.rpm-debuginfo.%{arch}' */
+	  s = strrchr (debuginfo, '-') - srcrpmlen;
+	  s2 = NULL;
+	  if (s > debuginfo && memcmp (s, ".src.rpm", srcrpmlen) == 0)
+	    {
+	      /* s2 = `-%{release}.src.rpm-debuginfo.%{arch}' */
+	      s2 = memrchr (debuginfo, '-', s - debuginfo);
+	    }
+	  if (s2)
+	    {
+	      /* s2 = `-%{version}-%{release}.src.rpm-debuginfo.%{arch}' */
+	      s2 = memrchr (debuginfo, '-', s2 - debuginfo);
+	    }
+	  if (!s2)
+	    {
+	      warning (_("Error querying the rpm file `%s': %s"), filename,
+	               debuginfo);
+	      xfree (debuginfo);
+	      continue;
+	    }
+	  /* s = `.src.rpm-debuginfo.%{arch}' */
+	  /* s2 = `-%{version}-%{release}.src.rpm-debuginfo.%{arch}' */
+	  memmove (s2 + debuginfolen, s2, s - s2);
+	  memcpy (s2, "-debuginfo", debuginfolen);
+	  /* s = `XXXX.%{arch}' */
+	  /* strlen ("XXXX") == srcrpmlen + debuginfolen */
+	  /* s2 = `-debuginfo-%{version}-%{release}XX.%{arch}' */
+	  /* strlen ("XX") == srcrpmlen */
+	  memmove (s + debuginfolen, s + srcrpmlen + debuginfolen,
+		   strlen (s + srcrpmlen + debuginfolen) + 1);
+	  /* s = `-debuginfo-%{version}-%{release}.%{arch}' */
+
+	  /* RPMDBI_PACKAGES requires keylen == sizeof (int).  */
+	  /* RPMDBI_LABEL is an interface for NVR-based dbiFindByLabel().  */
+	  mi_debuginfo = rpmtsInitIterator_p (ts, RPMDBI_LABEL, debuginfo, 0);
+	  xfree (debuginfo);
+	  if (mi_debuginfo)
+	    {
+	      rpmdbFreeIterator_p (mi_debuginfo);
+	      count = 0;
+	      break;
+	    }
+
+	  /* The allocated memory gets utilized below for MISSING_RPM_HASH.  */
+	  debuginfo = headerFormat_p (h,
+				      "%{name}-%{version}-%{release}.%{arch}",
+				      &err);
+	  if (!debuginfo)
+	    {
+	      warning (_("Error querying the rpm file `%s': %s"), filename,
+	               err);
+	      continue;
+	    }
+
+	  /* Base package name for `debuginfo-install'.  We do not use the
+	     `yum' command directly as the line
+		 yum --disablerepo='*' --enablerepo='*-debug*' \
+		     install NAME-debuginfo.ARCH
+	     would be more complicated than just:
+		 debuginfo-install NAME-VERSION-RELEASE.ARCH
+	     Do not supply the rpm base name (derived from .src.rpm name) as
+	     debuginfo-install is unable to install the debuginfo package if
+	     the base name PKG binary rpm is not installed while for example
+	     PKG-libs would be installed (RH Bug 467901).
+	     FUTURE: After multiple debuginfo versions simultaneously installed
+	     get supported the support for the VERSION-RELEASE tags handling
+	     may need an update.  */
+
+	  if (missing_rpm_hash == NULL)
+	    {
+	      /* DEL_F is passed NULL as MISSING_RPM_LIST's HTAB_DELETE
+		 should not deallocate the entries.  */
+
+	      missing_rpm_hash = htab_create_alloc (64, htab_hash_string,
+			       (int (*) (const void *, const void *)) streq,
+						    NULL, xcalloc, xfree);
+	    }
+	  slot = (char **) htab_find_slot (missing_rpm_hash, debuginfo, INSERT);
+	  /* XCALLOC never returns NULL.  */
+	  gdb_assert (slot != NULL);
+	  if (*slot == NULL)
+	    {
+	      struct missing_rpm *missing_rpm;
+
+	      *slot = debuginfo;
+
+	      missing_rpm = xmalloc (sizeof (*missing_rpm) + strlen (debuginfo));
+	      strcpy (missing_rpm->rpm, debuginfo);
+	      missing_rpm->next = missing_rpm_list;
+	      missing_rpm_list = missing_rpm;
+	      missing_rpm_list_entries++;
+	    }
+	  else
+	    xfree (debuginfo);
+	  count++;
+	}
+
+      rpmdbFreeIterator_p (mi);
+    }
+
+  rpmtsFree_p (ts);
+
+  return count;
+}
+
+static int
+missing_rpm_list_compar (const char *const *ap, const char *const *bp)
+{
+  return strcoll (*ap, *bp);
+}
+
+/* It returns a NULL-terminated array of strings needing to be FREEd.  It may
+   also return only NULL.  */
+
+static void
+missing_rpm_list_print (void)
+{
+  char **array, **array_iter;
+  struct missing_rpm *list_iter;
+  struct cleanup *cleanups;
+
+  if (missing_rpm_list_entries == 0)
+    return;
+
+  array = xmalloc (sizeof (*array) * missing_rpm_list_entries);
+  cleanups = make_cleanup (xfree, array);
+
+  array_iter = array;
+  for (list_iter = missing_rpm_list; list_iter != NULL;
+       list_iter = list_iter->next)
+    {
+      *array_iter++ = list_iter->rpm;
+    }
+  gdb_assert (array_iter == array + missing_rpm_list_entries);
+
+  qsort (array, missing_rpm_list_entries, sizeof (*array),
+	 (int (*) (const void *, const void *)) missing_rpm_list_compar);
+
+  printf_unfiltered (_("Missing separate debuginfos, use: %s"),
+		     "debuginfo-install");
+  for (array_iter = array; array_iter < array + missing_rpm_list_entries;
+       array_iter++)
+    {
+      putchar_unfiltered (' ');
+      puts_unfiltered (*array_iter);
+    }
+  putchar_unfiltered ('\n');
+
+  while (missing_rpm_list != NULL)
+    {
+      list_iter = missing_rpm_list;
+      missing_rpm_list = list_iter->next;
+      xfree (list_iter);
+    }
+  missing_rpm_list_entries = 0;
+
+  do_cleanups (cleanups);
+}
+
+static void
+missing_rpm_change (void)
+{
+  debug_flush_missing ();
+
+  gdb_assert (missing_rpm_list == NULL);
+  if (missing_rpm_hash != NULL)
+    {
+      htab_delete (missing_rpm_hash);
+      missing_rpm_hash = NULL;
+    }
+}
+
+enum missing_exec
+  {
+    /* Init state.  EXEC_BFD also still could be NULL.  */
+    MISSING_EXEC_NOT_TRIED,
+    /* We saw a non-NULL EXEC_BFD but RPM has no info about it.  */
+    MISSING_EXEC_NOT_FOUND,
+    /* We found EXEC_BFD by RPM and we either have its symbols (either embedded
+       or separate) or the main executable's RPM is now contained in
+       MISSING_RPM_HASH.  */
+    MISSING_EXEC_ENLISTED
+  };
+static enum missing_exec missing_exec = MISSING_EXEC_NOT_TRIED;
+
+#endif	/* HAVE_LIBRPM */
+
+void
+debug_flush_missing (void)
+{
+#ifdef HAVE_LIBRPM
+  missing_rpm_list_print ();
+#endif
+}
+
+/* This MISSING_FILEPAIR_HASH tracker is used only for the duplicite messages
+     yum --disablerepo='*' --enablerepo='*-debug*' install ...
+   avoidance.  */
+
+struct missing_filepair
+  {
+    char *binary;
+    char *debug;
+    char data[1];
+  };
+
+static struct htab *missing_filepair_hash;
+static struct obstack missing_filepair_obstack;
+
+static void *
+missing_filepair_xcalloc (size_t nmemb, size_t nmemb_size)
+{
+  void *retval;
+  size_t size = nmemb * nmemb_size;
+
+  retval = obstack_alloc (&missing_filepair_obstack, size);
+  memset (retval, 0, size);
   return retval;
 }
 
+static hashval_t
+missing_filepair_hash_func (const struct missing_filepair *elem)
+{
+  hashval_t retval = 0;
+
+  retval ^= htab_hash_string (elem->binary);
+  if (elem->debug != NULL)
+    retval ^= htab_hash_string (elem->debug);
+
+  return retval;
+}
+
+static int
+missing_filepair_eq (const struct missing_filepair *elem1,
+		       const struct missing_filepair *elem2)
+{
+  return strcmp (elem1->binary, elem2->binary) == 0
+         && ((elem1->debug == NULL) == (elem2->debug == NULL))
+         && (elem1->debug == NULL || strcmp (elem1->debug, elem2->debug) == 0);
+}
+
+static void
+missing_filepair_change (void)
+{
+  if (missing_filepair_hash != NULL)
+    {
+      obstack_free (&missing_filepair_obstack, NULL);
+      /* All their memory came just from missing_filepair_OBSTACK.  */
+      missing_filepair_hash = NULL;
+    }
+#ifdef HAVE_LIBRPM
+  missing_exec = MISSING_EXEC_NOT_TRIED;
+#endif
+}
+
+static void
+debug_print_executable_changed (void)
+{
+#ifdef HAVE_LIBRPM
+  missing_rpm_change ();
+#endif
+  missing_filepair_change ();
+}
+
+/* Notify user the file BINARY with (possibly NULL) associated separate debug
+   information file DEBUG is missing.  DEBUG may or may not be the build-id
+   file such as would be:
+     /usr/lib/debug/.build-id/dd/b1d2ce632721c47bb9e8679f369e2295ce71be.debug
+   */
+
+void
+debug_print_missing (const char *binary, const char *debug)
+{
+  size_t binary_len0 = strlen (binary) + 1;
+  size_t debug_len0 = debug ? strlen (debug) + 1 : 0;
+  struct missing_filepair missing_filepair_find;
+  struct missing_filepair *missing_filepair;
+  struct missing_filepair **slot;
+
+  if (build_id_verbose < BUILD_ID_VERBOSE_FILENAMES)
+    return;
+
+  if (missing_filepair_hash == NULL)
+    {
+      obstack_init (&missing_filepair_obstack);
+      missing_filepair_hash = htab_create_alloc (64,
+	(hashval_t (*) (const void *)) missing_filepair_hash_func,
+	(int (*) (const void *, const void *)) missing_filepair_eq, NULL,
+	missing_filepair_xcalloc, NULL);
+    }
+
+  /* Use MISSING_FILEPAIR_FIND first instead of calling obstack_alloc with
+     obstack_free in the case of a (rare) match.  The problem is ALLOC_F for
+     MISSING_FILEPAIR_HASH allocates from MISSING_FILEPAIR_OBSTACK maintenance
+     structures for MISSING_FILEPAIR_HASH.  Calling obstack_free would possibly
+     not to free only MISSING_FILEPAIR but also some such structures (allocated
+     during the htab_find_slot call).  */
+
+  missing_filepair_find.binary = (char *) binary;
+  missing_filepair_find.debug = (char *) debug;
+  slot = (struct missing_filepair **) htab_find_slot (missing_filepair_hash,
+						      &missing_filepair_find,
+						      INSERT);
+
+  /* While it may be still printed duplicitely with the missing debuginfo file
+   * it is due to once printing about the binary file build-id link and once
+   * about the .debug file build-id link as both the build-id symlinks are
+   * located in the debuginfo package.  */
+
+  if (*slot != NULL)
+    return;
+
+  missing_filepair = obstack_alloc (&missing_filepair_obstack,
+				      sizeof (*missing_filepair) - 1
+				      + binary_len0 + debug_len0);
+  missing_filepair->binary = missing_filepair->data;
+  memcpy (missing_filepair->binary, binary, binary_len0);
+  if (debug != NULL)
+    {
+      missing_filepair->debug = missing_filepair->binary + binary_len0;
+      memcpy (missing_filepair->debug, debug, debug_len0);
+    }
+  else
+    missing_filepair->debug = NULL;
+
+  *slot = missing_filepair;
+
+#ifdef HAVE_LIBRPM
+  if (missing_exec == MISSING_EXEC_NOT_TRIED)
+    {
+      char *exec_filename;
+
+      exec_filename = get_exec_file (0);
+      if (exec_filename != NULL)
+	{
+	  if (missing_rpm_enlist (exec_filename) == 0)
+	    missing_exec = MISSING_EXEC_NOT_FOUND;
+	  else
+	    missing_exec = MISSING_EXEC_ENLISTED;
+	}
+    }
+  if (missing_exec != MISSING_EXEC_ENLISTED)
+    if ((binary[0] == 0 || missing_rpm_enlist (binary) == 0)
+	&& (debug == NULL || missing_rpm_enlist (debug) == 0))
+#endif	/* HAVE_LIBRPM */
+      {
+	/* We do not collect and flush these messages as each such message
+	   already requires its own separate lines.  */
+
+	fprintf_unfiltered (gdb_stdlog,
+			    _("Missing separate debuginfo for %s\n"), binary);
+        if (debug != NULL)
+	  {
+	    const char *p = strrchr (debug, '/');
+	    fprintf_unfiltered (gdb_stdlog, _("Try: %s%.2s%.38s\"\n"),
+				"zypper install -C \"debuginfo(build-id)=",
+				p - 2, p + 1);
+	  }
+      }
+}
+
 static char *
-find_separate_debug_file_by_buildid (struct objfile *objfile)
+find_separate_debug_file_by_buildid (struct objfile *objfile,
+				     char **build_id_filename_return)
 {
   struct build_id *build_id;
 
-  build_id = build_id_bfd_get (objfile->obfd);
+  if (build_id_filename_return)
+    *build_id_filename_return = NULL;
+
+  build_id = build_id_bfd_shdr_get (objfile->obfd);
   if (build_id != NULL)
     {
       char *build_id_name;
 
-      build_id_name = build_id_to_debug_filename (build_id);
+      build_id_name = build_id_to_filename (build_id, build_id_filename_return,
+					    1);
       xfree (build_id);
       /* Prevent looping on a stripped .debug file.  */
       if (build_id_name != NULL
@@ -1180,7 +2178,7 @@ find_separate_debug_file_by_buildid (str
 	  xfree (build_id_name);
 	}
       else if (build_id_name != NULL)
-        return build_id_name;
+	return build_id_name;
     }
   return NULL;
 }
@@ -1400,9 +2398,10 @@ elf_symfile_read (struct objfile *objfil
      `.note.gnu.build-id'.  */
   else if (!objfile_has_partial_symbols (objfile))
     {
-      char *debugfile;
+      char *debugfile, *build_id_filename;
 
-      debugfile = find_separate_debug_file_by_buildid (objfile);
+      debugfile = find_separate_debug_file_by_buildid (objfile,
+						       &build_id_filename);
 
       if (debugfile == NULL)
 	debugfile = find_separate_debug_file_by_debuglink (objfile);
@@ -1414,6 +2413,12 @@ elf_symfile_read (struct objfile *objfil
 	  symbol_file_add_separate (abfd, symfile_flags, objfile);
 	  xfree (debugfile);
 	}
+      /* Check if any separate debug info has been extracted out.  */
+      else if (bfd_get_section_by_name (objfile->obfd, ".gnu_debuglink")
+	       != NULL)
+	debug_print_missing (objfile->name, build_id_filename);
+
+      xfree (build_id_filename);
     }
 }
 
@@ -1629,4 +2634,16 @@ _initialize_elfread (void)
 
   elf_objfile_gnu_ifunc_cache_data = register_objfile_data ();
   gnu_ifunc_fns_p = &elf_gnu_ifunc_fns;
+
+  add_setshow_zinteger_cmd ("build-id-verbose", no_class, &build_id_verbose,
+			    _("\
+Set debugging level of the build-id locator."), _("\
+Show debugging level of the build-id locator."), _("\
+Level 1 (default) enables printing the missing debug filenames,\n\
+level 2 also prints the parsing of binaries to find the identificators."),
+			    NULL,
+			    show_build_id_verbose,
+			    &setlist, &showlist);
+
+  observer_attach_executable_changed (debug_print_executable_changed);
 }
diff -rup gdb-7.4ori//gdb/event-top.c gdb-7.4/gdb/event-top.c
--- gdb-7.4ori//gdb/event-top.c	2012-01-06 05:43:11.000000000 +0100
+++ gdb-7.4/gdb/event-top.c	2012-05-10 11:26:26.311643428 +0200
@@ -36,6 +36,7 @@
 #include "observer.h"
 #include "continuations.h"
 #include "gdbcmd.h"		/* for dont_repeat() */
+#include "symfile.h"

 /* readline include files.  */
 #include "readline/readline.h"
@@ -176,6 +177,8 @@ rl_callback_read_char_wrapper (gdb_clien
 void
 cli_command_loop (void)
 {
+  debug_flush_missing ();
+
   display_gdb_prompt (0);

   /* Now it's time to start the event loop.  */
@@ -241,6 +244,8 @@ display_gdb_prompt (char *new_prompt)
   /* Reset the nesting depth used when trace-commands is set.  */
   reset_command_nest_depth ();

+  debug_flush_missing ();
+
   /* Each interpreter has its own rules on displaying the command
      prompt.  */
   if (!current_interp_display_prompt_p ())
diff -rup gdb-7.4ori//gdb/objfiles.h gdb-7.4/gdb/objfiles.h
--- gdb-7.4ori//gdb/objfiles.h	2012-01-06 05:43:21.000000000 +0100
+++ gdb-7.4/gdb/objfiles.h	2012-05-10 11:10:37.459644929 +0200
@@ -433,6 +433,10 @@ struct objfile
 
 #define OBJF_MAINLINE (1 << 5)
 
+/* This file was loaded according to the BUILD_ID_CORE_LOADS rules.  */
+
+#define OBJF_BUILD_ID_CORE_LOADED (1 << 12)
+
 /* The object file that contains the runtime common minimal symbols
    for SunOS4.  Note that this objfile has no associated BFD.  */
 
diff -rup gdb-7.4ori//gdb/proc-service.list gdb-7.4/gdb/proc-service.list
--- gdb-7.4ori//gdb/proc-service.list	2012-01-06 05:43:25.000000000 +0100
+++ gdb-7.4/gdb/proc-service.list	2012-05-10 11:27:09.947643359 +0200
@@ -37,4 +37,7 @@
   ps_pstop;
   ps_ptread;
   ps_ptwrite;
+
+  /* gdb-6.6-buildid-locate-rpm.patch */
+  rpmsqEnable;
 };
diff -rup gdb-7.4ori//gdb/solib-svr4.c gdb-7.4/gdb/solib-svr4.c
--- gdb-7.4ori//gdb/solib-svr4.c	2012-01-06 05:43:30.000000000 +0100
+++ gdb-7.4/gdb/solib-svr4.c	2012-05-10 11:10:37.455644929 +0200
@@ -1227,9 +1227,52 @@ svr4_read_so_list (CORE_ADDR lm, struct
 	  continue;
 	}
 
-      strncpy (new->so_name, buffer, SO_NAME_MAX_PATH_SIZE - 1);
-      new->so_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
-      strcpy (new->so_original_name, new->so_name);
+      {
+	struct build_id *build_id;
+
+	strncpy (new->so_original_name, buffer, SO_NAME_MAX_PATH_SIZE - 1);
+	new->so_original_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
+	/* May get overwritten below.  */
+	strcpy (new->so_name, new->so_original_name);
+
+	build_id = build_id_addr_get (new->lm_info->l_ld);
+	if (build_id != NULL)
+	  {
+	    char *name, *build_id_filename;
+
+	    /* Missing the build-id matching separate debug info file
+	       would be handled while SO_NAME gets loaded.  */
+	    name = build_id_to_filename (build_id, &build_id_filename, 0);
+	    if (name != NULL)
+	      {
+		strncpy (new->so_name, name, SO_NAME_MAX_PATH_SIZE - 1);
+		new->so_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
+		xfree (name);
+	      }
+	    else
+	      {
+		debug_print_missing (new->so_name, build_id_filename);
+
+		/* In the case the main executable was found according to
+		   its build-id (from a core file) prevent loading
+		   a different build of a library with accidentally the
+		   same SO_NAME.
+
+		   It suppresses bogus backtraces (and prints "??" there
+		   instead) if the on-disk files no longer match the
+		   running program version.  */
+
+		if (symfile_objfile != NULL
+		    && (symfile_objfile->flags
+			& OBJF_BUILD_ID_CORE_LOADED) != 0)
+		  new->so_name[0] = 0;
+	      }
+
+	    xfree (build_id_filename);
+	    xfree (build_id);
+	  }
+      }
+
       xfree (buffer);
 
       /* If this entry has no name, or its name matches the name
diff -rup gdb-7.4ori//gdb/symfile.h gdb-7.4/gdb/symfile.h
--- gdb-7.4ori//gdb/symfile.h	2012-01-06 05:43:31.000000000 +0100
+++ gdb-7.4/gdb/symfile.h	2012-05-10 11:26:26.311643428 +0200
@@ -560,6 +560,15 @@ void free_symfile_segment_data (struct s
 
 extern struct cleanup *increment_reading_symtab (void);
 
+/* build-id support.  */
+struct build_id;
+extern struct build_id *build_id_addr_get (CORE_ADDR addr);
+extern char *build_id_to_filename (struct build_id *build_id,
+				   char **link_return, int add_debug_suffix);
+extern void debug_print_missing (const char *binary, const char *debug);
+extern void debug_flush_missing (void);
+#define BUILD_ID_MAIN_EXECUTABLE_FILENAME _("the main executable file")
+
 /* From dwarf2read.c */
 
 /* Names for a dwarf2 debugging section.  The field NORMAL is the normal
diff -rup gdb-7.4ori//gdb/testsuite/lib/gdb.exp gdb-7.4/gdb/testsuite/lib/gdb.exp
--- gdb-7.4ori//gdb/testsuite/lib/gdb.exp	2012-01-06 05:54:30.000000000 +0100
+++ gdb-7.4/gdb/testsuite/lib/gdb.exp	2012-05-10 11:26:26.315643428 +0200
@@ -1392,6 +1392,16 @@ proc default_gdb_start { } {
 	    warning "Couldn't set the width to 0."
 	}
     }
+    # Turn off the missing RPMs warnings as the testsuite does not expect it.
+    send_gdb "set build-id-verbose 0\n"
+    gdb_expect 10 {
+	-re "$gdb_prompt $" {
+	    verbose "Disabled the missing debug infos warnings." 2
+	}
+	timeout {
+	    warning "Could not disable the missing debug infos warnings.."
+	}
+    }
     return 0;
 }
 
diff -rup gdb-7.4ori//gdb/testsuite/lib/mi-support.exp gdb-7.4/gdb/testsuite/lib/mi-support.exp
--- gdb-7.4ori//gdb/testsuite/lib/mi-support.exp	2012-01-06 05:54:30.000000000 +0100
+++ gdb-7.4/gdb/testsuite/lib/mi-support.exp	2012-05-10 11:26:26.315643428 +0200
@@ -212,6 +212,16 @@ proc default_mi_gdb_start { args } {
 	    warning "Couldn't set the width to 0."
 	}
     }
+    # Turn off the missing RPMs warnings as the testsuite does not expect it.
+    send_gdb "190-gdb-set build-id-verbose 0\n"
+    gdb_expect 10 {
+	-re ".*190-gdb-set build-id-verbose 0\r\n190\\\^done\r\n$mi_gdb_prompt$" {
+	    verbose "Disabled the missing debug infos warnings." 2
+	}
+	timeout {
+	    warning "Could not disable the missing debug infos warnings.."
+	}
+    }
     # If allowing the inferior to have its own PTY then assign the inferior
     # its own terminal device here.
     if { $separate_inferior_pty } {
diff -rup gdb-7.4ori//gdb/tui/tui-interp.c gdb-7.4/gdb/tui/tui-interp.c
--- gdb-7.4ori//gdb/tui/tui-interp.c	2012-01-06 05:54:35.000000000 +0100
+++ gdb-7.4/gdb/tui/tui-interp.c	2012-05-10 11:26:26.315643428 +0200
@@ -30,6 +30,7 @@
 #include "tui/tui.h"
 #include "tui/tui-io.h"
 #include "exceptions.h"
+#include "symfile.h"

 /* Set to 1 when the TUI mode must be activated when we first start
    gdb.  */
