diff -urN a/ksrc/drivers/serial/Kconfig b/ksrc/drivers/serial/Kconfig
--- a/ksrc/drivers/serial/Kconfig	2016-02-27 23:45:36.628322152 +0100
+++ b/ksrc/drivers/serial/Kconfig	2016-02-27 23:23:34.405471156 +0100
@@ -68,7 +68,14 @@
 	tristate "RT IMX UART driver"
 	select RATIONAL
 	help
-	Real-time UART driver for the Freescale Semiconductor MXC Internal
-	UART compatible controllers.
+	Real-time UART driver for the Freescale Semiconductor
+	MXC Internal UART compatible controllers.
+
+config XENO_DRIVERS_IMX_MXS_AUART
+	depends on XENO_SKIN_RTDM && (ARCH_IMX || ARCH_MXS)
+	tristate "RT IMX MXS AUART driver"
+	help
+	Real-time application UART driver for Sigmatel-based
+	MXS Internal UART compatible controllers.
 
 endmenu
diff -urN a/ksrc/drivers/serial/Makefile b/ksrc/drivers/serial/Makefile
--- a/ksrc/drivers/serial/Makefile	2016-02-27 23:45:36.628322152 +0100
+++ b/ksrc/drivers/serial/Makefile	2016-02-27 23:23:55.001860625 +0100
@@ -6,9 +6,11 @@
 
 obj-$(CONFIG_XENO_DRIVERS_16550A) += xeno_16550A.o
 obj-$(CONFIG_XENO_DRIVERS_IMX_UART) += xeno_imx_uart.o
+obj-$(CONFIG_XENO_DRIVERS_IMX_MXS_AUART) += xeno_imx_mxs_auart.o
 
 xeno_16550A-y := 16550A.o
 xeno_imx_uart-y := rt_imx_uart.o
+xeno_imx_mxs_auart-y := rt_imx_mxs_auart.o
 
 else
 
diff -urN a/ksrc/drivers/serial/regs-uartapp.h b/ksrc/drivers/serial/regs-uartapp.h
--- a/ksrc/drivers/serial/regs-uartapp.h	1970-01-01 01:00:00.000000000 +0100
+++ b/ksrc/drivers/serial/regs-uartapp.h	2016-01-22 01:04:55.000000000 +0100
@@ -0,0 +1,307 @@
+/*
+ * Freescale UARTAPP Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.42
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___UARTAPP_H
+#define __ARCH_ARM___UARTAPP_H
+
+
+#define HW_UARTAPP_CTRL0	(0x00000000)
+#define HW_UARTAPP_CTRL0_SET	(0x00000004)
+#define HW_UARTAPP_CTRL0_CLR	(0x00000008)
+#define HW_UARTAPP_CTRL0_TOG	(0x0000000c)
+
+#define BM_UARTAPP_CTRL0_SFTRST	0x80000000
+#define BM_UARTAPP_CTRL0_CLKGATE	0x40000000
+#define BM_UARTAPP_CTRL0_RUN	0x20000000
+#define BM_UARTAPP_CTRL0_RX_SOURCE	0x10000000
+#define BM_UARTAPP_CTRL0_RXTO_ENABLE	0x08000000
+#define BP_UARTAPP_CTRL0_RXTIMEOUT	16
+#define BM_UARTAPP_CTRL0_RXTIMEOUT	0x07FF0000
+#define BF_UARTAPP_CTRL0_RXTIMEOUT(v)  \
+		(((v) << 16) & BM_UARTAPP_CTRL0_RXTIMEOUT)
+#define BP_UARTAPP_CTRL0_XFER_COUNT	0
+#define BM_UARTAPP_CTRL0_XFER_COUNT	0x0000FFFF
+#define BF_UARTAPP_CTRL0_XFER_COUNT(v)  \
+		(((v) << 0) & BM_UARTAPP_CTRL0_XFER_COUNT)
+
+#define HW_UARTAPP_CTRL1	(0x00000010)
+#define HW_UARTAPP_CTRL1_SET	(0x00000014)
+#define HW_UARTAPP_CTRL1_CLR	(0x00000018)
+#define HW_UARTAPP_CTRL1_TOG	(0x0000001c)
+
+#define BP_UARTAPP_CTRL1_RSVD2	29
+#define BM_UARTAPP_CTRL1_RSVD2	0xE0000000
+#define BF_UARTAPP_CTRL1_RSVD2(v) \
+		(((v) << 29) & BM_UARTAPP_CTRL1_RSVD2)
+#define BM_UARTAPP_CTRL1_RUN	0x10000000
+#define BP_UARTAPP_CTRL1_RSVD1	16
+#define BM_UARTAPP_CTRL1_RSVD1	0x0FFF0000
+#define BF_UARTAPP_CTRL1_RSVD1(v)  \
+		(((v) << 16) & BM_UARTAPP_CTRL1_RSVD1)
+#define BP_UARTAPP_CTRL1_XFER_COUNT	0
+#define BM_UARTAPP_CTRL1_XFER_COUNT	0x0000FFFF
+#define BF_UARTAPP_CTRL1_XFER_COUNT(v)  \
+		(((v) << 0) & BM_UARTAPP_CTRL1_XFER_COUNT)
+
+#define HW_UARTAPP_CTRL2	(0x00000020)
+#define HW_UARTAPP_CTRL2_SET	(0x00000024)
+#define HW_UARTAPP_CTRL2_CLR	(0x00000028)
+#define HW_UARTAPP_CTRL2_TOG	(0x0000002c)
+
+#define BM_UARTAPP_CTRL2_INVERT_RTS	0x80000000
+#define BM_UARTAPP_CTRL2_INVERT_CTS	0x40000000
+#define BM_UARTAPP_CTRL2_INVERT_TX	0x20000000
+#define BM_UARTAPP_CTRL2_INVERT_RX	0x10000000
+#define BM_UARTAPP_CTRL2_RTS_SEMAPHORE	0x08000000
+#define BM_UARTAPP_CTRL2_DMAONERR	0x04000000
+#define BM_UARTAPP_CTRL2_TXDMAE	0x02000000
+#define BM_UARTAPP_CTRL2_RXDMAE	0x01000000
+#define BM_UARTAPP_CTRL2_RSVD2	0x00800000
+#define BP_UARTAPP_CTRL2_RXIFLSEL	20
+#define BM_UARTAPP_CTRL2_RXIFLSEL	0x00700000
+#define BF_UARTAPP_CTRL2_RXIFLSEL(v)  \
+		(((v) << 20) & BM_UARTAPP_CTRL2_RXIFLSEL)
+#define BV_UARTAPP_CTRL2_RXIFLSEL__NOT_EMPTY      0x0
+#define BV_UARTAPP_CTRL2_RXIFLSEL__ONE_QUARTER    0x1
+#define BV_UARTAPP_CTRL2_RXIFLSEL__ONE_HALF       0x2
+#define BV_UARTAPP_CTRL2_RXIFLSEL__THREE_QUARTERS 0x3
+#define BV_UARTAPP_CTRL2_RXIFLSEL__SEVEN_EIGHTHS  0x4
+#define BV_UARTAPP_CTRL2_RXIFLSEL__INVALID5       0x5
+#define BV_UARTAPP_CTRL2_RXIFLSEL__INVALID6       0x6
+#define BV_UARTAPP_CTRL2_RXIFLSEL__INVALID7       0x7
+#define BM_UARTAPP_CTRL2_RSVD3	0x00080000
+#define BP_UARTAPP_CTRL2_TXIFLSEL	16
+#define BM_UARTAPP_CTRL2_TXIFLSEL	0x00070000
+#define BF_UARTAPP_CTRL2_TXIFLSEL(v)  \
+		(((v) << 16) & BM_UARTAPP_CTRL2_TXIFLSEL)
+#define BV_UARTAPP_CTRL2_TXIFLSEL__EMPTY          0x0
+#define BV_UARTAPP_CTRL2_TXIFLSEL__ONE_QUARTER    0x1
+#define BV_UARTAPP_CTRL2_TXIFLSEL__ONE_HALF       0x2
+#define BV_UARTAPP_CTRL2_TXIFLSEL__THREE_QUARTERS 0x3
+#define BV_UARTAPP_CTRL2_TXIFLSEL__SEVEN_EIGHTHS  0x4
+#define BV_UARTAPP_CTRL2_TXIFLSEL__INVALID5       0x5
+#define BV_UARTAPP_CTRL2_TXIFLSEL__INVALID6       0x6
+#define BV_UARTAPP_CTRL2_TXIFLSEL__INVALID7       0x7
+#define BM_UARTAPP_CTRL2_CTSEN	0x00008000
+#define BM_UARTAPP_CTRL2_RTSEN	0x00004000
+#define BM_UARTAPP_CTRL2_OUT2	0x00002000
+#define BM_UARTAPP_CTRL2_OUT1	0x00001000
+#define BM_UARTAPP_CTRL2_RTS	0x00000800
+#define BM_UARTAPP_CTRL2_DTR	0x00000400
+#define BM_UARTAPP_CTRL2_RXE	0x00000200
+#define BM_UARTAPP_CTRL2_TXE	0x00000100
+#define BM_UARTAPP_CTRL2_LBE	0x00000080
+#define BM_UARTAPP_CTRL2_USE_LCR2	0x00000040
+#define BP_UARTAPP_CTRL2_RSVD4	3
+#define BM_UARTAPP_CTRL2_RSVD4	0x00000038
+#define BF_UARTAPP_CTRL2_RSVD4(v)  \
+		(((v) << 3) & BM_UARTAPP_CTRL2_RSVD4)
+#define BM_UARTAPP_CTRL2_SIRLP	0x00000004
+#define BM_UARTAPP_CTRL2_SIREN	0x00000002
+#define BM_UARTAPP_CTRL2_UARTEN	0x00000001
+
+#define HW_UARTAPP_LINECTRL	(0x00000030)
+#define HW_UARTAPP_LINECTRL_SET	(0x00000034)
+#define HW_UARTAPP_LINECTRL_CLR	(0x00000038)
+#define HW_UARTAPP_LINECTRL_TOG	(0x0000003c)
+
+#define BP_UARTAPP_LINECTRL_BAUD_DIVINT	16
+#define BM_UARTAPP_LINECTRL_BAUD_DIVINT	0xFFFF0000
+#define BF_UARTAPP_LINECTRL_BAUD_DIVINT(v) \
+		(((v) << 16) & BM_UARTAPP_LINECTRL_BAUD_DIVINT)
+#define BP_UARTAPP_LINECTRL_RSVD	14
+#define BM_UARTAPP_LINECTRL_RSVD	0x0000C000
+#define BF_UARTAPP_LINECTRL_RSVD(v)  \
+		(((v) << 14) & BM_UARTAPP_LINECTRL_RSVD)
+#define BP_UARTAPP_LINECTRL_BAUD_DIVFRAC	8
+#define BM_UARTAPP_LINECTRL_BAUD_DIVFRAC	0x00003F00
+#define BF_UARTAPP_LINECTRL_BAUD_DIVFRAC(v)  \
+		(((v) << 8) & BM_UARTAPP_LINECTRL_BAUD_DIVFRAC)
+#define BM_UARTAPP_LINECTRL_SPS	0x00000080
+#define BP_UARTAPP_LINECTRL_WLEN	5
+#define BM_UARTAPP_LINECTRL_WLEN	0x00000060
+#define BF_UARTAPP_LINECTRL_WLEN(v)  \
+		(((v) << 5) & BM_UARTAPP_LINECTRL_WLEN)
+#define BM_UARTAPP_LINECTRL_FEN	0x00000010
+#define BM_UARTAPP_LINECTRL_STP2	0x00000008
+#define BM_UARTAPP_LINECTRL_EPS	0x00000004
+#define BM_UARTAPP_LINECTRL_PEN	0x00000002
+#define BM_UARTAPP_LINECTRL_BRK	0x00000001
+
+#define HW_UARTAPP_LINECTRL2	(0x00000040)
+#define HW_UARTAPP_LINECTRL2_SET	(0x00000044)
+#define HW_UARTAPP_LINECTRL2_CLR	(0x00000048)
+#define HW_UARTAPP_LINECTRL2_TOG	(0x0000004c)
+
+#define BP_UARTAPP_LINECTRL2_BAUD_DIVINT	16
+#define BM_UARTAPP_LINECTRL2_BAUD_DIVINT	0xFFFF0000
+#define BF_UARTAPP_LINECTRL2_BAUD_DIVINT(v) \
+		(((v) << 16) & BM_UARTAPP_LINECTRL2_BAUD_DIVINT)
+#define BP_UARTAPP_LINECTRL2_RSVD	14
+#define BM_UARTAPP_LINECTRL2_RSVD	0x0000C000
+#define BF_UARTAPP_LINECTRL2_RSVD(v)  \
+		(((v) << 14) & BM_UARTAPP_LINECTRL2_RSVD)
+#define BP_UARTAPP_LINECTRL2_BAUD_DIVFRAC	8
+#define BM_UARTAPP_LINECTRL2_BAUD_DIVFRAC	0x00003F00
+#define BF_UARTAPP_LINECTRL2_BAUD_DIVFRAC(v)  \
+		(((v) << 8) & BM_UARTAPP_LINECTRL2_BAUD_DIVFRAC)
+#define BM_UARTAPP_LINECTRL2_SPS	0x00000080
+#define BP_UARTAPP_LINECTRL2_WLEN	5
+#define BM_UARTAPP_LINECTRL2_WLEN	0x00000060
+#define BF_UARTAPP_LINECTRL2_WLEN(v)  \
+		(((v) << 5) & BM_UARTAPP_LINECTRL2_WLEN)
+#define BM_UARTAPP_LINECTRL2_FEN	0x00000010
+#define BM_UARTAPP_LINECTRL2_STP2	0x00000008
+#define BM_UARTAPP_LINECTRL2_EPS	0x00000004
+#define BM_UARTAPP_LINECTRL2_PEN	0x00000002
+#define BM_UARTAPP_LINECTRL2_RSVD1	0x00000001
+
+#define HW_UARTAPP_INTR	(0x00000050)
+#define HW_UARTAPP_INTR_SET	(0x00000054)
+#define HW_UARTAPP_INTR_CLR	(0x00000058)
+#define HW_UARTAPP_INTR_TOG	(0x0000005c)
+
+#define BP_UARTAPP_INTR_RSVD1	28
+#define BM_UARTAPP_INTR_RSVD1	0xF0000000
+#define BF_UARTAPP_INTR_RSVD1(v) \
+		(((v) << 28) & BM_UARTAPP_INTR_RSVD1)
+#define BM_UARTAPP_INTR_ABDIEN	0x08000000
+#define BM_UARTAPP_INTR_OEIEN	0x04000000
+#define BM_UARTAPP_INTR_BEIEN	0x02000000
+#define BM_UARTAPP_INTR_PEIEN	0x01000000
+#define BM_UARTAPP_INTR_FEIEN	0x00800000
+#define BM_UARTAPP_INTR_RTIEN	0x00400000
+#define BM_UARTAPP_INTR_TXIEN	0x00200000
+#define BM_UARTAPP_INTR_RXIEN	0x00100000
+#define BM_UARTAPP_INTR_DSRMIEN	0x00080000
+#define BM_UARTAPP_INTR_DCDMIEN	0x00040000
+#define BM_UARTAPP_INTR_CTSMIEN	0x00020000
+#define BM_UARTAPP_INTR_RIMIEN	0x00010000
+#define BP_UARTAPP_INTR_RSVD2	12
+#define BM_UARTAPP_INTR_RSVD2	0x0000F000
+#define BF_UARTAPP_INTR_RSVD2(v)  \
+		(((v) << 12) & BM_UARTAPP_INTR_RSVD2)
+#define BM_UARTAPP_INTR_ABDIS	0x00000800
+#define BM_UARTAPP_INTR_OEIS	0x00000400
+#define BM_UARTAPP_INTR_BEIS	0x00000200
+#define BM_UARTAPP_INTR_PEIS	0x00000100
+#define BM_UARTAPP_INTR_FEIS	0x00000080
+#define BM_UARTAPP_INTR_RTIS	0x00000040
+#define BM_UARTAPP_INTR_TXIS	0x00000020
+#define BM_UARTAPP_INTR_RXIS	0x00000010
+#define BM_UARTAPP_INTR_DSRMIS	0x00000008
+#define BM_UARTAPP_INTR_DCDMIS	0x00000004
+#define BM_UARTAPP_INTR_CTSMIS	0x00000002
+#define BM_UARTAPP_INTR_RIMIS	0x00000001
+
+#define HW_UARTAPP_DATA	(0x00000060)
+
+#define BP_UARTAPP_DATA_DATA	0
+#define BM_UARTAPP_DATA_DATA	0xFFFFFFFF
+#define BF_UARTAPP_DATA_DATA(v)	(v)
+
+#define HW_UARTAPP_STAT	(0x00000070)
+
+#define BM_UARTAPP_STAT_PRESENT	0x80000000
+#define BV_UARTAPP_STAT_PRESENT__UNAVAILABLE 0x0
+#define BV_UARTAPP_STAT_PRESENT__AVAILABLE   0x1
+#define BM_UARTAPP_STAT_HISPEED	0x40000000
+#define BV_UARTAPP_STAT_HISPEED__UNAVAILABLE 0x0
+#define BV_UARTAPP_STAT_HISPEED__AVAILABLE   0x1
+#define BM_UARTAPP_STAT_BUSY	0x20000000
+#define BM_UARTAPP_STAT_CTS	0x10000000
+#define BM_UARTAPP_STAT_TXFE	0x08000000
+#define BM_UARTAPP_STAT_RXFF	0x04000000
+#define BM_UARTAPP_STAT_TXFF	0x02000000
+#define BM_UARTAPP_STAT_RXFE	0x01000000
+#define BP_UARTAPP_STAT_RXBYTE_INVALID	20
+#define BM_UARTAPP_STAT_RXBYTE_INVALID	0x00F00000
+#define BF_UARTAPP_STAT_RXBYTE_INVALID(v)  \
+		(((v) << 20) & BM_UARTAPP_STAT_RXBYTE_INVALID)
+#define BM_UARTAPP_STAT_OERR	0x00080000
+#define BM_UARTAPP_STAT_BERR	0x00040000
+#define BM_UARTAPP_STAT_PERR	0x00020000
+#define BM_UARTAPP_STAT_FERR	0x00010000
+#define BP_UARTAPP_STAT_RXCOUNT	0
+#define BM_UARTAPP_STAT_RXCOUNT	0x0000FFFF
+#define BF_UARTAPP_STAT_RXCOUNT(v)  \
+		(((v) << 0) & BM_UARTAPP_STAT_RXCOUNT)
+
+#define HW_UARTAPP_DEBUG	(0x00000080)
+
+#define BP_UARTAPP_DEBUG_RXIBAUD_DIV	16
+#define BM_UARTAPP_DEBUG_RXIBAUD_DIV	0xFFFF0000
+#define BF_UARTAPP_DEBUG_RXIBAUD_DIV(v) \
+		(((v) << 16) & BM_UARTAPP_DEBUG_RXIBAUD_DIV)
+#define BP_UARTAPP_DEBUG_RXFBAUD_DIV	10
+#define BM_UARTAPP_DEBUG_RXFBAUD_DIV	0x0000FC00
+#define BF_UARTAPP_DEBUG_RXFBAUD_DIV(v)  \
+		(((v) << 10) & BM_UARTAPP_DEBUG_RXFBAUD_DIV)
+#define BP_UARTAPP_DEBUG_RSVD1	6
+#define BM_UARTAPP_DEBUG_RSVD1	0x000003C0
+#define BF_UARTAPP_DEBUG_RSVD1(v)  \
+		(((v) << 6) & BM_UARTAPP_DEBUG_RSVD1)
+#define BM_UARTAPP_DEBUG_TXDMARUN	0x00000020
+#define BM_UARTAPP_DEBUG_RXDMARUN	0x00000010
+#define BM_UARTAPP_DEBUG_TXCMDEND	0x00000008
+#define BM_UARTAPP_DEBUG_RXCMDEND	0x00000004
+#define BM_UARTAPP_DEBUG_TXDMARQ	0x00000002
+#define BM_UARTAPP_DEBUG_RXDMARQ	0x00000001
+
+#define HW_UARTAPP_VERSION	(0x00000090)
+
+#define BP_UARTAPP_VERSION_MAJOR	24
+#define BM_UARTAPP_VERSION_MAJOR	0xFF000000
+#define BF_UARTAPP_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_UARTAPP_VERSION_MAJOR)
+#define BP_UARTAPP_VERSION_MINOR	16
+#define BM_UARTAPP_VERSION_MINOR	0x00FF0000
+#define BF_UARTAPP_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_UARTAPP_VERSION_MINOR)
+#define BP_UARTAPP_VERSION_STEP	0
+#define BM_UARTAPP_VERSION_STEP	0x0000FFFF
+#define BF_UARTAPP_VERSION_STEP(v)  \
+		(((v) << 0) & BM_UARTAPP_VERSION_STEP)
+
+#define HW_UARTAPP_AUTOBAUD	(0x000000a0)
+
+#define BP_UARTAPP_AUTOBAUD_REFCHAR1	24
+#define BM_UARTAPP_AUTOBAUD_REFCHAR1	0xFF000000
+#define BF_UARTAPP_AUTOBAUD_REFCHAR1(v) \
+		(((v) << 24) & BM_UARTAPP_AUTOBAUD_REFCHAR1)
+#define BP_UARTAPP_AUTOBAUD_REFCHAR0	16
+#define BM_UARTAPP_AUTOBAUD_REFCHAR0	0x00FF0000
+#define BF_UARTAPP_AUTOBAUD_REFCHAR0(v)  \
+		(((v) << 16) & BM_UARTAPP_AUTOBAUD_REFCHAR0)
+#define BP_UARTAPP_AUTOBAUD_RSVD1	5
+#define BM_UARTAPP_AUTOBAUD_RSVD1	0x0000FFE0
+#define BF_UARTAPP_AUTOBAUD_RSVD1(v)  \
+		(((v) << 5) & BM_UARTAPP_AUTOBAUD_RSVD1)
+#define BM_UARTAPP_AUTOBAUD_UPDATE_TX	0x00000010
+#define BM_UARTAPP_AUTOBAUD_TWO_REF_CHARS	0x00000008
+#define BM_UARTAPP_AUTOBAUD_START_WITH_RUNBIT	0x00000004
+#define BM_UARTAPP_AUTOBAUD_START_BAUD_DETECT	0x00000002
+#define BM_UARTAPP_AUTOBAUD_BAUD_DETECT_ENABLE	0x00000001
+#endif /* __ARCH_ARM___UARTAPP_H */
diff -urN a/ksrc/drivers/serial/rt_imx_mxs_auart.c b/ksrc/drivers/serial/rt_imx_mxs_auart.c
--- a/ksrc/drivers/serial/rt_imx_mxs_auart.c	1970-01-01 01:00:00.000000000 +0100
+++ b/ksrc/drivers/serial/rt_imx_mxs_auart.c	2016-02-27 18:37:45.090170000 +0100
@@ -0,0 +1,1392 @@
+/*
+ * Copyright 2016 MECT s.r.l. <info@mect.it>
+ *
+ * Derived from Freescale STMP37XX/STMP378X Application UART driver.
+ *
+ * Author: Mihai Lazarescu <mlazarescu@mect.it>
+ *
+ * Copyright 2012 Wolfgang Grandegger <wg@denx.de>
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/platform_device.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+
+#include <asm/cacheflush.h>
+
+#include <mach/hardware.h>
+#include <mach/device.h>
+
+#include <rtdm/rtserial.h>
+#include <rtdm/rtdm_driver.h>
+
+#include "regs-uartapp.h"
+
+#ifdef CONFIG_MECT_CUSTOMIZATION
+#undef CONFIG_MECT_CUSTOMIZATION
+/* For EWK board */
+#define MECT_RTS_TX_ACTIVE_LOW
+#endif
+
+
+#define DRIVER_NAME		"xeno_imx_mxs_auart"
+
+#define IN_BUFFER_SIZE		4096
+#define OUT_BUFFER_SIZE		4096
+
+#define IER_RX			0x01
+#define IER_TX			0x02
+#define IER_STAT		0x04
+#define IER_MODEM		0x08
+
+struct rt_imx_mxs_auart_port {
+	struct uart_port port;
+
+	unsigned int flags;
+	unsigned int irq[3];
+	unsigned int use_hwflow;
+
+	struct clk *clk;
+	struct device *dev;
+	struct list_head rx_done;
+	struct list_head free;
+	struct tasklet_struct rx_task;
+	struct rtdm_device rtdm_dev;	/* RTDM device structure */
+};
+
+struct rt_imx_mxs_auart_ctx {
+	struct rtser_config config;	/* current device configuration */
+
+	rtdm_irq_t irq_handle;		/* device IRQ handle */
+	rtdm_lock_t lock;		/* lock to protect context struct */
+
+	int in_head;			/* RX ring buffer, head pointer */
+	int in_tail;			/* RX ring buffer, tail pointer */
+	size_t in_npend;		/* pending bytes in RX ring */
+	int in_nwait;			/* bytes the user waits for */
+	rtdm_event_t in_event;		/* raised to unblock reader */
+	char in_buf[IN_BUFFER_SIZE];	/* RX ring buffer */
+	volatile unsigned long in_lock; /* single-reader lock */
+	uint64_t *in_history;		/* RX timestamp buffer */
+
+	int out_head;			/* TX ring buffer, head pointer */
+	int out_tail;			/* TX ring buffer, tail pointer */
+	size_t out_npend;		/* pending bytes in TX ring */
+	rtdm_event_t out_event;		/* raised to unblock writer */
+	char out_buf[OUT_BUFFER_SIZE];	/* TX ring buffer */
+	rtdm_mutex_t out_lock;		/* single-writer mutex */
+
+	uint64_t last_timestamp;	/* timestamp of last event */
+	int ioc_events;			/* recorded events */
+	rtdm_event_t ioc_event;		/* raised to unblock event waiter */
+	volatile unsigned long ioc_event_lock;	/* single-waiter lock */
+
+	int ier_status;			/* IER cache */
+	int mcr_status;			/* MCR cache */
+	int status;			/* cache for LSR + soft-states */
+	int saved_errors;		/* error cache for RTIOC_GET_STATUS */
+
+	/*
+	 * The port structure holds all the information about the UART
+	 * port like base address, and so on.
+	 */
+	struct rt_imx_mxs_auart_port *port;
+};
+
+#define PARITY_MASK             0x03
+#define DATA_BITS_MASK          0x03
+#define STOP_BITS_MASK          0x01
+#define FIFO_MASK               0xC0
+#define EVENT_MASK              0x0F
+
+static const struct rtser_config default_config = {
+	.config_mask = 0xFFFF,
+	.baud_rate = RTSER_DEF_BAUD,
+	.parity = RTSER_DEF_PARITY,
+	.data_bits = RTSER_DEF_BITS,
+	.stop_bits = RTSER_DEF_STOPB,
+	.handshake = RTSER_DEF_HAND,
+	.fifo_depth = RTSER_DEF_FIFO_DEPTH,
+	.rx_timeout = RTSER_DEF_TIMEOUT,
+	.tx_timeout = RTSER_DEF_TIMEOUT,
+	.event_timeout = RTSER_DEF_TIMEOUT,
+	.timestamp_history = RTSER_DEF_TIMESTAMP_HISTORY,
+	.event_mask = RTSER_DEF_EVENT_MASK,
+};
+
+static void rt_imx_mxs_auart_break_ctl(struct rt_imx_mxs_auart_ctx *ctx, int break_state);
+static int rt_imx_mxs_auart_set_config(struct rt_imx_mxs_auart_ctx *ctx, const struct rtser_config *config, uint64_t **in_history_ptr);
+static void rt_imx_mxs_auart_stop_tx(struct rt_imx_mxs_auart_ctx *ctx);
+
+static int rt_imx_mxs_auart_rx_chars(struct rt_imx_mxs_auart_ctx *ctx, uint64_t *timestamp);
+
+static inline struct rt_imx_mxs_auart_port *
+to_auart_port(struct uart_port *u)
+{
+	return container_of(u, struct rt_imx_mxs_auart_port, port);
+}
+
+static void
+rt_imx_mxs_auart_set_mctrl(struct uart_port *u, unsigned mctrl)
+{
+	struct rt_imx_mxs_auart_port *port = NULL;
+	u32 ctrl = 0;
+
+	port = to_auart_port(u);
+	ctrl = __raw_readl(u->membase + HW_UARTAPP_CTRL2);
+
+	ctrl &= ~BM_UARTAPP_CTRL2_RTS;
+#ifdef CONFIG_MECT_CUSTOMIZATION
+	if ((mctrl & TIOCM_RTS) == TIOCM_RTS)
+#else
+	if (mctrl & TIOCM_RTS)
+#endif
+		ctrl |= BM_UARTAPP_CTRL2_RTS;
+
+	__raw_writel(ctrl, u->membase + HW_UARTAPP_CTRL2);
+}
+
+static inline void
+rt_imx_mxs_auart_tx_chars(struct rt_imx_mxs_auart_ctx *ctx)
+{
+	struct rt_imx_mxs_auart_port *port = ctx->port;
+	int count;
+	int ch;
+
+	for (count = port->port.fifosize; (!(__raw_readl(port->port.membase + HW_UARTAPP_STAT) & BM_UARTAPP_STAT_TXFF)) && (count > 0) && (ctx->out_npend > 0); count--, ctx->out_npend--) {
+		ch = ctx->out_buf[ctx->out_head++];
+		__raw_writel(ch, port->port.membase + HW_UARTAPP_DATA);
+
+		ctx->out_head &= (OUT_BUFFER_SIZE - 1);
+	}
+
+	if (port->port.fifosize)
+		__raw_writel(BM_UARTAPP_INTR_TXIEN, port->port.membase + HW_UARTAPP_INTR_SET);
+	else {
+		__raw_writel(BM_UARTAPP_INTR_TXIEN, port->port.membase + HW_UARTAPP_INTR_CLR);
+#ifdef CONFIG_MECT_CUSTOMIZATION
+		/* Wait for transmitter to become empty and restore RTS */
+		while (__raw_readl(port->port.membase + HW_UARTAPP_STAT) & BM_UARTAPP_STAT_BUSY) ;
+
+#ifdef MECT_RTS_TX_ACTIVE_LOW
+		rt_imx_mxs_auart_set_mctrl(&port->port, TIOCM_RTS);
+#else
+		rt_imx_mxs_auart_set_mctrl(&port->port, 0);
+#endif
+		/* Start RX */
+		__raw_writel(BM_UARTAPP_CTRL2_RXE, port->port.membase + HW_UARTAPP_CTRL2_SET);
+#endif
+	}
+}
+
+static int
+rt_imx_mxs_auart_rx_chars(struct rt_imx_mxs_auart_ctx *ctx, uint64_t *timestamp)
+{
+	struct rt_imx_mxs_auart_port *port = ctx->port;
+	u8 c = 0;
+	u32 stat = 0;
+	unsigned int max_count = 0;
+	int rbytes = 0;
+	int lsr = 0;
+
+	for (max_count = 256; max_count > 0; max_count--) {
+		stat = __raw_readl(port->port.membase + HW_UARTAPP_STAT);
+		if (stat & BM_UARTAPP_STAT_RXFE)
+			break;
+
+		c = __raw_readl(port->port.membase + HW_UARTAPP_DATA);
+
+		if (stat & BM_UARTAPP_STAT_BERR) {
+			stat &= ~BM_UARTAPP_STAT_BERR;
+			ctx->port->port.icount.brk++;
+
+			/* NOTE Here we ignore break requests. */
+
+			lsr |= RTSER_LSR_BREAK_IND;
+		}
+		else if (stat & BM_UARTAPP_STAT_PERR) {
+			stat &= ~BM_UARTAPP_STAT_PERR;
+			port->port.icount.parity++;
+
+			lsr |= RTSER_LSR_PARITY_ERR;
+		}
+		else if (stat & BM_UARTAPP_STAT_FERR) {
+			stat &= ~BM_UARTAPP_STAT_FERR;
+			port->port.icount.frame++;
+
+			lsr |= RTSER_LSR_FRAMING_ERR;
+		}
+
+		if (stat & BM_UARTAPP_STAT_OERR) {
+			port->port.icount.overrun++;
+
+			lsr |= RTSER_LSR_OVERRUN_ERR;
+		}
+
+		/* NOTE Here we ignore system requests. */
+
+		/* Save the received character */
+		ctx->in_buf[ctx->in_tail] = c;
+
+		if (ctx->in_history)
+			ctx->in_history[ctx->in_tail] = *timestamp;
+
+		ctx->in_tail = (ctx->in_tail + 1) & (IN_BUFFER_SIZE - 1);
+
+		if (++ctx->in_npend > IN_BUFFER_SIZE) {
+			ctx->in_npend--;
+
+			lsr |= RTSER_SOFT_OVERRUN_ERR;
+		}
+
+		rbytes++;
+
+		__raw_writel(stat, port->port.membase + HW_UARTAPP_STAT);
+	}
+
+	__raw_writel(stat, port->port.membase + HW_UARTAPP_STAT);
+
+	/* Save new errors */
+	ctx->status |= lsr;
+
+	return rbytes;
+}
+
+static unsigned int
+rt_imx_mxs_auart_get_msr(struct rt_imx_mxs_auart_ctx *ctx)
+{
+	unsigned int msr = 0;
+
+	/* Nothing to report. */
+
+	return msr;
+}
+
+static void
+rt_imx_mxs_auart_set_mcr(struct rt_imx_mxs_auart_ctx *ctx, unsigned int mcr)
+{
+	struct rt_imx_mxs_auart_port *port = ctx->port;
+	int ctrl2 = __raw_readl(port->port.membase + HW_UARTAPP_CTRL2);
+
+	/* Set hardware flow control. */
+	if (mcr & RTSER_MCR_RTS) {
+		/* Switch to hardware-driven hardware flow control */
+		if (ctx->port->use_hwflow)
+			ctrl2 |= BM_UARTAPP_CTRL2_CTSEN /* | BM_UARTAPP_CTRL2_RTSEN */;
+		else
+			ctrl2 &= ~BM_UARTAPP_CTRL2_CTSEN /* & ~BM_UARTAPP_CTRL2_RTSEN */;
+	}
+	else
+		ctrl2 &= ~BM_UARTAPP_CTRL2_CTSEN /* & ~BM_UARTAPP_CTRL2_RTSEN */;
+
+	/* Set loopback. */
+	if (mcr & RTSER_MCR_LOOP)
+		ctrl2 |= BM_UARTAPP_CTRL2_LBE;
+	else
+		ctrl2 &= ~BM_UARTAPP_CTRL2_LBE;
+
+	__raw_writel(ctrl2, port->port.membase + HW_UARTAPP_CTRL2);
+}
+
+static int
+rt_imx_mxs_auart_ioctl(struct rtdm_dev_context *context, rtdm_user_info_t *user_info, unsigned int request, void *arg)
+{
+	rtdm_lockctx_t lock_ctx;
+	struct rt_imx_mxs_auart_ctx *ctx;
+	int err = 0;
+
+	ctx = (struct rt_imx_mxs_auart_ctx *)context->dev_private;
+
+	switch (request) {
+		case RTSER_RTIOC_GET_CONFIG:
+			if (user_info)
+				err = rtdm_safe_copy_to_user(user_info, arg, &ctx->config, sizeof(struct rtser_config));
+			else
+				memcpy(arg, &ctx->config, sizeof(struct rtser_config));
+
+			break;
+
+		case RTSER_RTIOC_SET_CONFIG: {
+			struct rtser_config *config;
+			struct rtser_config config_buf;
+			uint64_t *hist_buf = NULL;
+
+			config = (struct rtser_config *)arg;
+
+			if (user_info) {
+				err = rtdm_safe_copy_from_user(user_info, &config_buf, arg, sizeof(struct rtser_config));
+				if (err)
+					return err;
+
+				config = &config_buf;
+			}
+
+			if (testbits(config->config_mask, RTSER_SET_BAUD) && (config->baud_rate > clk_get_rate(ctx->port->clk) * 32 || config->baud_rate <= 0))
+				/* invalid baudrate for this port */
+				return -EINVAL;
+
+			if (testbits(config->config_mask, RTSER_SET_TIMESTAMP_HISTORY)) {
+				/* Reject in RT context since we allocate/free the buffer. */
+				if (rtdm_in_rt_context())
+					return -ENOSYS;
+
+				if (testbits(config->timestamp_history, RTSER_RX_TIMESTAMP_HISTORY))
+					hist_buf = kmalloc(IN_BUFFER_SIZE * sizeof(nanosecs_abs_t), GFP_KERNEL);
+			}
+
+			rt_imx_mxs_auart_set_config(ctx, config, &hist_buf);
+
+			if (hist_buf)
+				kfree(hist_buf);
+
+			break;
+		}
+
+		case RTSER_RTIOC_GET_STATUS: {
+			int status;
+			int msr;
+
+			rtdm_lock_get_irqsave(&ctx->lock, lock_ctx);
+
+			status = ctx->saved_errors | ctx->status;
+			ctx->status = 0;
+			ctx->saved_errors = 0;
+			ctx->ioc_events &= ~RTSER_EVENT_ERRPEND;
+
+			msr = rt_imx_mxs_auart_get_msr(ctx);
+
+			rtdm_lock_put_irqrestore(&ctx->lock, lock_ctx);
+
+			if (user_info) {
+				struct rtser_status status_buf;
+
+				status_buf.line_status = status;
+				status_buf.modem_status = msr;
+				err = rtdm_safe_copy_to_user(user_info, arg, &status_buf, sizeof(struct rtser_status));
+			}
+			else {
+				((struct rtser_status *)arg)->line_status = 0;
+				((struct rtser_status *)arg)->modem_status = msr;
+			}
+
+			break;
+		}
+
+		case RTSER_RTIOC_GET_CONTROL:
+			if (user_info)
+				err = rtdm_safe_copy_to_user(user_info, arg, &ctx->mcr_status, sizeof(int));
+			else
+				*(int *)arg = ctx->mcr_status;
+
+			break;
+
+		case RTSER_RTIOC_SET_CONTROL: {
+			int new_mcr = (long)arg;
+
+			rtdm_lock_get_irqsave(&ctx->lock, lock_ctx);
+
+			ctx->mcr_status = new_mcr;
+			rt_imx_mxs_auart_set_mcr(ctx, new_mcr);
+
+			rtdm_lock_put_irqrestore(&ctx->lock, lock_ctx);
+
+			break;
+		}
+
+		case RTSER_RTIOC_WAIT_EVENT: {
+			struct rtser_event ev = {
+				.rxpend_timestamp = 0
+			};
+			rtdm_toseq_t timeout_seq;
+
+			if (!rtdm_in_rt_context())
+				return -ENOSYS;
+
+			/* Only one waiter allowed, stop any further attempts here. */
+			if (test_and_set_bit(0, &ctx->ioc_event_lock))
+				return -EBUSY;
+
+			rtdm_toseq_init(&timeout_seq, ctx->config.event_timeout);
+
+			rtdm_lock_get_irqsave(&ctx->lock, lock_ctx);
+
+			while (!ctx->ioc_events) {
+				/* Enable error interrupt only when the user waits for it. */
+				if (testbits(ctx->config.event_mask, RTSER_EVENT_ERRPEND))
+					ctx->ier_status |= IER_STAT;
+
+				rtdm_lock_put_irqrestore(&ctx->lock, lock_ctx);
+
+				err = rtdm_event_timedwait(&ctx->ioc_event, ctx->config.event_timeout, &timeout_seq);
+				if (err) {
+					/* Device has been closed? */
+					if (err == -EIDRM)
+						err = -EBADF;
+
+					goto wait_unlock_out;
+				}
+
+				rtdm_lock_get_irqsave(&ctx->lock, lock_ctx);
+			}
+
+			ev.events = ctx->ioc_events;
+			ctx->ioc_events &= ~(RTSER_EVENT_MODEMHI | RTSER_EVENT_MODEMLO);
+
+			ev.last_timestamp = ctx->last_timestamp;
+			ev.rx_pending = ctx->in_npend;
+
+			if (ctx->in_history)
+				ev.rxpend_timestamp = ctx->in_history[ctx->in_head];
+
+			rtdm_lock_put_irqrestore(&ctx->lock, lock_ctx);
+
+			if (user_info)
+				err = rtdm_safe_copy_to_user(user_info, arg, &ev, sizeof(struct rtser_event));
+			else
+				memcpy(arg, &ev, sizeof(struct rtser_event));
+
+wait_unlock_out:
+			/* Release the simple event waiter lock */
+			clear_bit(0, &ctx->ioc_event_lock);
+
+			break;
+		}
+
+		case RTSER_RTIOC_BREAK_CTL: {
+			rtdm_lock_get_irqsave(&ctx->lock, lock_ctx);
+
+			rt_imx_mxs_auart_break_ctl(ctx, (int)arg);
+
+			rtdm_lock_put_irqrestore(&ctx->lock, lock_ctx);
+
+			break;
+		}
+
+		default:
+			err = -ENOTTY;
+	}
+
+	return err;
+}
+
+static int
+rt_imx_mxs_auart_irq_handle(rtdm_irq_t *irq_context)
+{
+	uint64_t timestamp = rtdm_clock_read();
+	struct rt_imx_mxs_auart_ctx *ctx;
+	int rbytes = 0;
+	int events = 0;
+	int ret = RTDM_IRQ_NONE;
+	u32 istatus;
+	u32 istat;
+	struct rt_imx_mxs_auart_port *port;
+	u32 stat;
+
+	ctx = rtdm_irq_get_arg(irq_context, struct rt_imx_mxs_auart_ctx);
+
+	rtdm_lock_get(&ctx->lock);
+
+	port = ctx->port;
+
+	stat = __raw_readl(port->port.membase + HW_UARTAPP_STAT);
+
+	istatus = istat = __raw_readl(port->port.membase + HW_UARTAPP_INTR);
+
+	/* RX data ready or RX timeout */
+	if (istat & (BM_UARTAPP_INTR_RXIS | BM_UARTAPP_INTR_RTIS)) {
+		rbytes += rt_imx_mxs_auart_rx_chars(ctx, &timestamp);
+
+		events |= RTSER_EVENT_RXPEND;
+		ret = RTDM_IRQ_HANDLED;
+
+		istat &= ~(BM_UARTAPP_INTR_RTIS | BM_UARTAPP_INTR_RXIS);
+	}
+
+	/* TX ready */
+	if (istat & BM_UARTAPP_INTR_TXIS) {
+		rt_imx_mxs_auart_tx_chars(ctx);
+
+		ret = RTDM_IRQ_HANDLED;
+
+		istat &= ~BM_UARTAPP_INTR_TXIS;
+	}
+
+	/* Modem CTS */
+	if (istat & BM_UARTAPP_INTR_CTSMIS) {
+		__raw_writel(BM_UARTAPP_INTR_CTSMIS, port->port.membase + HW_UARTAPP_INTR_CLR);
+
+		istat &= ~BM_UARTAPP_INTR_CTSMIS;
+
+		/* FIXME: should generate an RTDM event. */
+
+		ret = RTDM_IRQ_HANDLED;
+	}
+
+	/* Modem status interrupt bits are undefined after reset and
+	DSRMIS, DCDMIS and RIMIS are not supported. So, we ingore them. */
+	if (istat & (BM_UARTAPP_INTR_ABDIS
+		     | BM_UARTAPP_INTR_OEIS
+		     | BM_UARTAPP_INTR_BEIS
+		     | BM_UARTAPP_INTR_PEIS
+		     | BM_UARTAPP_INTR_FEIS
+		     | BM_UARTAPP_INTR_RTIS
+		     | BM_UARTAPP_INTR_TXIS
+		     | BM_UARTAPP_INTR_RXIS
+		     | BM_UARTAPP_INTR_CTSMIS))
+		dev_info(port->dev, "Unhandled status %x\n", istat);
+
+	__raw_writel(istatus & (BM_UARTAPP_INTR_ABDIS
+				| BM_UARTAPP_INTR_OEIS
+				| BM_UARTAPP_INTR_BEIS
+				| BM_UARTAPP_INTR_PEIS
+				| BM_UARTAPP_INTR_FEIS
+				| BM_UARTAPP_INTR_RTIS
+				| BM_UARTAPP_INTR_TXIS
+				| BM_UARTAPP_INTR_RXIS
+				| BM_UARTAPP_INTR_DSRMIS
+				| BM_UARTAPP_INTR_DCDMIS
+				| BM_UARTAPP_INTR_CTSMIS
+				| BM_UARTAPP_INTR_RIMIS),
+		port->port.membase + HW_UARTAPP_INTR_CLR);
+
+	if (ctx->in_nwait > 0) {
+		if ((ctx->in_nwait <= rbytes) || ctx->status) {
+			ctx->in_nwait = 0;
+
+			rtdm_event_signal(&ctx->in_event);
+		}
+		else
+			ctx->in_nwait -= rbytes;
+	}
+
+	if (ctx->status)
+		events |= RTSER_EVENT_ERRPEND;
+
+	if (testbits(events, ctx->config.event_mask)) {
+		int old_events = ctx->ioc_events;
+
+		ctx->last_timestamp = timestamp;
+		ctx->ioc_events = events;
+
+		if (!old_events)
+			rtdm_event_signal(&ctx->ioc_event);
+	}
+
+	if (testbits(ctx->ier_status, IER_TX) && (ctx->out_npend == 0)) {
+		rt_imx_mxs_auart_stop_tx(ctx);
+
+		ctx->ier_status &= ~IER_TX;
+
+		rtdm_event_signal(&ctx->out_event);
+	}
+
+	rtdm_lock_put(&ctx->lock);
+
+	if (ret != RTDM_IRQ_HANDLED)
+		printk(KERN_WARNING "%s: unhandled interrupt 0x%X\n", __func__, istat);
+
+	return ret;
+}
+
+static inline void
+rt_imx_mxs_auart_reset(struct uart_port *u)
+{
+	int i;
+	unsigned int reg;
+
+	__raw_writel(BM_UARTAPP_CTRL0_SFTRST, u->membase + HW_UARTAPP_CTRL0_CLR);
+
+	for (i = 0; i < 10000; i++) {
+		reg = __raw_readl(u->membase + HW_UARTAPP_CTRL0);
+		if (!(reg & BM_UARTAPP_CTRL0_SFTRST))
+			break;
+
+		udelay(3);
+	}
+
+	__raw_writel(BM_UARTAPP_CTRL0_CLKGATE, u->membase + HW_UARTAPP_CTRL0_CLR);
+}
+
+static void
+rt_imx_mxs_auart_start_tx(struct rt_imx_mxs_auart_ctx *ctx)
+{
+	struct rt_imx_mxs_auart_port *port = ctx->port;
+
+#ifdef CONFIG_MECT_CUSTOMIZATION
+	/* RTS set */
+
+	/* Stop RX */
+	__raw_writel(BM_UARTAPP_CTRL2_RXE, port->port.membase + HW_UARTAPP_CTRL2_CLR);
+#ifdef MECT_RTS_TX_ACTIVE_LOW
+	rt_imx_mxs_auart_set_mctrl(&port->port, 0);
+#else
+	rt_imx_mxs_auart_set_mctrl(&port->port, TIOCM_RTS);
+#endif
+#endif
+
+	/* Enable TX */
+	__raw_writel(BM_UARTAPP_CTRL2_TXE, port->port.membase + HW_UARTAPP_CTRL2_SET);
+
+	/* FIXME Not in MXC. Needed? */
+	rt_imx_mxs_auart_tx_chars(ctx);
+}
+
+static void
+rt_imx_mxs_auart_stop_tx(struct rt_imx_mxs_auart_ctx *ctx)
+{
+	__raw_writel(BM_UARTAPP_CTRL2_TXE, ctx->port->port.membase + HW_UARTAPP_CTRL2_CLR);
+}
+
+static void
+rt_imx_mxs_auart_break_ctl(struct rt_imx_mxs_auart_ctx *ctx, int break_state)
+{
+	struct rt_imx_mxs_auart_port *port = ctx->port;
+
+	if (break_state == RTSER_BREAK_SET)
+		__raw_writel(BM_UARTAPP_LINECTRL_BRK, port->port.membase + HW_UARTAPP_LINECTRL_SET);
+	else
+		__raw_writel(BM_UARTAPP_LINECTRL_BRK, port->port.membase + HW_UARTAPP_LINECTRL_CLR);
+}
+
+static int
+rt_imx_mxs_auart_set_config(struct rt_imx_mxs_auart_ctx *ctx, const struct rtser_config *config, uint64_t **in_history_ptr)
+{
+	rtdm_lockctx_t lock_ctx;
+	int err = 0;
+
+	pr_info("In %s\n", __func__);
+
+	rtdm_lock_get_irqsave(&ctx->lock, lock_ctx);
+
+	if (testbits(config->config_mask, RTSER_SET_BAUD))
+		ctx->config.baud_rate = config->baud_rate;
+
+	if (testbits(config->config_mask, RTSER_SET_DATA_BITS))
+		ctx->config.data_bits = config->data_bits & DATA_BITS_MASK;
+
+	if (testbits(config->config_mask, RTSER_SET_PARITY))
+		ctx->config.parity = config->parity & PARITY_MASK;
+
+	if (testbits(config->config_mask, RTSER_SET_STOP_BITS))
+		ctx->config.stop_bits = config->stop_bits & STOP_BITS_MASK;
+
+	/* Timeout manipulation is not atomic.  The user should
+	   not use and change the timeouts at the same time. */
+	if (testbits(config->config_mask, RTSER_SET_TIMEOUT_RX))
+		ctx->config.rx_timeout = config->rx_timeout;
+
+	if (testbits(config->config_mask, RTSER_SET_TIMEOUT_TX))
+		ctx->config.tx_timeout = config->tx_timeout;
+
+	if (testbits(config->config_mask, RTSER_SET_TIMEOUT_EVENT))
+		ctx->config.event_timeout = config->event_timeout;
+
+	if (testbits(config->config_mask, RTSER_SET_TIMESTAMP_HISTORY)) {
+		if (testbits(config->timestamp_history, RTSER_RX_TIMESTAMP_HISTORY)) {
+			if (!ctx->in_history) {
+				ctx->in_history = *in_history_ptr;
+				*in_history_ptr = NULL;
+
+				if (!ctx->in_history)
+					err = -ENOMEM;
+			}
+		}
+		else {
+			*in_history_ptr = ctx->in_history;
+			ctx->in_history = NULL;
+		}
+	}
+
+	if (testbits(config->config_mask, RTSER_SET_EVENT_MASK)) {
+		ctx->config.event_mask = config->event_mask & EVENT_MASK;
+		ctx->ioc_events = 0;
+
+		if (testbits(config->event_mask, RTSER_EVENT_RXPEND) && (ctx->in_npend > 0))
+			ctx->ioc_events |= RTSER_EVENT_RXPEND;
+
+		if (testbits(config->event_mask, RTSER_EVENT_ERRPEND) && ctx->status)
+			ctx->ioc_events |= RTSER_EVENT_ERRPEND;
+	}
+
+	if (testbits(config->config_mask, RTSER_SET_HANDSHAKE))
+		ctx->config.handshake = config->handshake;
+
+	/*
+	 * Configure the hardware.
+	 */
+	if (testbits(config->config_mask, (RTSER_SET_DATA_BITS
+					   | RTSER_SET_HANDSHAKE 
+					   | RTSER_SET_STOP_BITS
+					   | RTSER_SET_PARITY
+					   | RTSER_SET_BAUD
+					   | RTSER_SET_EVENT_MASK))) {
+		u32 ctrl;
+		u32 ctrl2;
+		u32 div;
+
+		/* Get HW configuration. */
+		ctrl = __raw_readl(ctx->port->port.membase + HW_UARTAPP_LINECTRL);
+		ctrl2 = __raw_readl(ctx->port->port.membase + HW_UARTAPP_CTRL2);
+
+		/* Enable FIFO. */
+		ctrl |= BM_UARTAPP_LINECTRL_FEN;
+
+		/* Data size: either 8 or 7 bit */
+		ctrl &= ~BF_UARTAPP_LINECTRL_WLEN(0xffffffff);
+		if (ctx->config.data_bits == RTSER_8_BITS)
+			ctrl |= BF_UARTAPP_LINECTRL_WLEN(3);
+		else
+			ctrl |= BF_UARTAPP_LINECTRL_WLEN(2);
+
+		/* Hardware flow control (RTS/CTS) */
+		/* NOTE: RTS leaved out for RS485. */
+		if (ctx->config.handshake == RTSER_RTSCTS_HAND)
+			ctrl2 |= BM_UARTAPP_CTRL2_CTSEN /* | BM_UARTAPP_CTRL2_RTSEN */;
+		else
+			ctrl2 &= ~BM_UARTAPP_CTRL2_CTSEN /* & ~BM_UARTAPP_CTRL2_RTSEN */;
+
+		/* Stop bits (1 or 2) */
+		ctrl &= ~BM_UARTAPP_LINECTRL_STP2;
+		if (ctx->config.stop_bits == RTSER_2_STOPB)
+			ctrl |= BM_UARTAPP_LINECTRL_STP2;
+		else if (ctx->config.stop_bits == RTSER_1_STOPB)
+			ctrl &= ~BM_UARTAPP_LINECTRL_STP2;
+
+		/* Parity check: either even or odd. */
+		ctrl &= ~BM_UARTAPP_LINECTRL_PEN;
+		if ((ctx->config.parity == RTSER_ODD_PARITY) || (ctx->config.parity == RTSER_EVEN_PARITY)) {
+			ctrl |= BM_UARTAPP_LINECTRL_PEN;
+			if (ctx->config.parity == RTSER_EVEN_PARITY)
+				ctrl |= BM_UARTAPP_LINECTRL_EPS;
+		}
+
+		/* Baud rate */
+		{
+			u32 uc = 0;
+
+			uc = ctx->port->port.uartclk << 5;
+
+			div = uc / ctx->config.baud_rate;
+			/* Round to nearest integer. */
+			if (((div + 1) * ctx->config.baud_rate - uc) < (uc - div * ctx->config.baud_rate))
+				div++;
+		}
+
+		ctrl &= ~BF_UARTAPP_LINECTRL_BAUD_DIVFRAC(0xffffffff);
+		ctrl |= BF_UARTAPP_LINECTRL_BAUD_DIVFRAC(div);
+
+		ctrl &= ~BF_UARTAPP_LINECTRL_BAUD_DIVINT(0xffffffff);
+		ctrl |= BF_UARTAPP_LINECTRL_BAUD_DIVINT(div >> 6);
+
+		/* Set up the HW. */
+		__raw_writel(ctrl, ctx->port->port.membase + HW_UARTAPP_LINECTRL);
+		__raw_writel(ctrl2, ctx->port->port.membase + HW_UARTAPP_CTRL2);
+
+		ctx->status = 0;
+		ctx->ioc_events &= ~RTSER_EVENT_ERRPEND;
+	}
+
+	rtdm_lock_put_irqrestore(&ctx->lock, lock_ctx);
+
+	return err;
+}
+
+static ssize_t
+rt_imx_mxs_auart_write(struct rtdm_dev_context *context, rtdm_user_info_t *user_info, const void *buf, size_t nbyte)
+{
+	struct rt_imx_mxs_auart_ctx *ctx;
+	rtdm_lockctx_t lock_ctx;
+	size_t written = 0;
+	int free;
+	int block;
+	int subblock;
+	int out_pos;
+	char *in_pos = (char *)buf;
+	rtdm_toseq_t timeout_seq;
+	ssize_t ret;
+
+	if (nbyte == 0)
+		return 0;
+
+	if (user_info && !rtdm_read_user_ok(user_info, buf, nbyte))
+		return -EFAULT;
+
+	ctx = (struct rt_imx_mxs_auart_ctx *)context->dev_private;
+
+	rtdm_toseq_init(&timeout_seq, ctx->config.rx_timeout);
+
+	/* Make write operation atomic. */
+	ret = rtdm_mutex_timedlock(&ctx->out_lock, ctx->config.rx_timeout, &timeout_seq);
+	if (ret)
+		return ret;
+
+	while (nbyte > 0) {
+		rtdm_lock_get_irqsave(&ctx->lock, lock_ctx);
+
+		free = OUT_BUFFER_SIZE - ctx->out_npend;
+
+		if (free > 0) {
+			block = subblock = (nbyte <= free) ? nbyte : free;
+			out_pos = ctx->out_tail;
+
+			rtdm_lock_put_irqrestore(&ctx->lock, lock_ctx);
+
+			/* Wrap around buffer end? */
+			if (out_pos + subblock > OUT_BUFFER_SIZE) {
+				/* Treat the block between head and buffer end separately. */
+				subblock = OUT_BUFFER_SIZE - out_pos;
+
+				if (user_info) {
+					if (rtdm_copy_from_user(user_info, &ctx->out_buf[out_pos], in_pos, subblock) != 0) {
+						ret = -EFAULT;
+
+						break;
+					}
+				}
+				else
+					memcpy(&ctx->out_buf[out_pos], in_pos, subblock);
+
+				written += subblock;
+				in_pos += subblock;
+
+				subblock = block - subblock;
+				out_pos = 0;
+			}
+
+			if (user_info) {
+				if (rtdm_copy_from_user(user_info, &ctx->out_buf[out_pos], in_pos, subblock) != 0) {
+					ret = -EFAULT;
+
+					break;
+				}
+			}
+			else
+				memcpy(&ctx->out_buf[out_pos], in_pos, block);
+
+			written += subblock;
+			in_pos += subblock;
+			nbyte -= block;
+
+			rtdm_lock_get_irqsave(&ctx->lock, lock_ctx);
+
+			ctx->out_tail = (ctx->out_tail + block) & (OUT_BUFFER_SIZE - 1);
+			ctx->out_npend += block;
+
+			ctx->ier_status |= IER_TX;
+
+			rt_imx_mxs_auart_start_tx(ctx);
+
+			rtdm_lock_put_irqrestore(&ctx->lock, lock_ctx);
+
+			continue;
+		}
+
+		rtdm_lock_put_irqrestore(&ctx->lock, lock_ctx);
+
+		ret = rtdm_event_timedwait(&ctx->out_event, ctx->config.tx_timeout, &timeout_seq);
+		if (ret < 0) {
+			if (ret == -EIDRM)
+				/* Device has been closed - return immediately. */
+				return -EBADF;
+
+			if (ret == -EWOULDBLOCK)
+				/* Fix error code for non-blocking mode. */
+				ret = -EAGAIN;
+
+			break;
+		}
+	}
+
+	rtdm_mutex_unlock(&ctx->out_lock);
+
+	if ((written > 0) && ((ret == 0) || (ret == -EAGAIN) || (ret == -ETIMEDOUT) || (ret == -EINTR)))
+		ret = written;
+
+	return ret;
+}
+
+ssize_t
+rt_imx_mxs_auart_read(struct rtdm_dev_context *context, rtdm_user_info_t *user_info, void *buf, size_t nbyte)
+{
+	struct rt_imx_mxs_auart_ctx *ctx;
+	rtdm_lockctx_t lock_ctx;
+	size_t read = 0;
+	int pending;
+	int block;
+	int subblock;
+	int in_pos;
+	char *out_pos = (char *)buf;
+	rtdm_toseq_t timeout_seq;
+	ssize_t ret = -EAGAIN;	/* for non-blocking read */
+	int nonblocking;
+
+	if (nbyte == 0)
+		return 0;
+
+	if (user_info && !rtdm_rw_user_ok(user_info, buf, nbyte))
+		return -EFAULT;
+
+	ctx = (struct rt_imx_mxs_auart_ctx *)context->dev_private;
+
+	rtdm_toseq_init(&timeout_seq, ctx->config.rx_timeout);
+
+	/* non-blocking is handled separately here */
+	nonblocking = (ctx->config.rx_timeout < 0);
+
+	/* only one reader allowed, stop any further attempts here */
+	if (test_and_set_bit(0, &ctx->in_lock))
+		return -EBUSY;
+
+	rtdm_lock_get_irqsave(&ctx->lock, lock_ctx);
+
+	while (1) {
+		if (ctx->status) {
+			if (testbits(ctx->status, RTSER_LSR_BREAK_IND))
+				ret = -EPIPE;
+			else
+				ret = -EIO;
+
+			ctx->saved_errors = ctx->status & (RTSER_LSR_OVERRUN_ERR | RTSER_LSR_PARITY_ERR | RTSER_LSR_FRAMING_ERR | RTSER_SOFT_OVERRUN_ERR);
+			ctx->status = 0;
+
+			break;
+		}
+
+		pending = ctx->in_npend;
+
+		if (pending > 0) {
+			block = subblock = (pending <= nbyte) ? pending : nbyte;
+			in_pos = ctx->in_head;
+
+			rtdm_lock_put_irqrestore(&ctx->lock, lock_ctx);
+
+			/* Wrap around buffer end? */
+			if (in_pos + subblock > IN_BUFFER_SIZE) {
+				/* Treat the block between head and buffer end separately. */
+				subblock = IN_BUFFER_SIZE - in_pos;
+
+				if (user_info) {
+					if (rtdm_copy_to_user(user_info, out_pos, &ctx->in_buf[in_pos], subblock) != 0) {
+						ret = -EFAULT;
+
+						goto break_unlocked;
+					}
+				}
+				else
+					memcpy(out_pos, &ctx->in_buf[in_pos], subblock);
+
+				read += subblock;
+				out_pos += subblock;
+
+				subblock = block - subblock;
+				in_pos = 0;
+			}
+
+			if (user_info) {
+				if (rtdm_copy_to_user(user_info, out_pos, &ctx->in_buf[in_pos], subblock) != 0) {
+					ret = -EFAULT;
+
+					goto break_unlocked;
+				}
+			}
+			else
+				memcpy(out_pos, &ctx->in_buf[in_pos], subblock);
+
+			read += subblock;
+			out_pos += subblock;
+			nbyte -= block;
+
+			rtdm_lock_get_irqsave(&ctx->lock, lock_ctx);
+
+			ctx->in_head = (ctx->in_head + block) & (IN_BUFFER_SIZE - 1);
+			ctx->in_npend -= block;
+			if (ctx->in_npend == 0)
+				ctx->ioc_events &= ~RTSER_EVENT_RXPEND;
+
+			if (nbyte == 0)
+				break; /* All requested bytes were read. */
+
+			continue;
+		}
+
+		/* ret was set to EAGAIN in case of a real non-blocking call
+		   or contains the error returned by rtdm_event_wait[_until] */
+		if (nonblocking)
+			break;
+
+		ctx->in_nwait = nbyte;
+
+		rtdm_lock_put_irqrestore(&ctx->lock, lock_ctx);
+
+		ret = rtdm_event_timedwait(&ctx->in_event, ctx->config.rx_timeout, &timeout_seq);
+		if (ret < 0) {
+			if (ret == -EIDRM)
+				/* Device has been closed - return immediately. */
+				return -EBADF;
+
+			rtdm_lock_get_irqsave(&ctx->lock, lock_ctx);
+
+			nonblocking = 1;
+			if (ctx->in_npend > 0)
+				/* Final turn: collect pending bytes before exit. */
+				continue;
+
+			ctx->in_nwait = 0;
+
+			break;
+		}
+
+		rtdm_lock_get_irqsave(&ctx->lock, lock_ctx);
+	}
+
+	rtdm_lock_put_irqrestore(&ctx->lock, lock_ctx);
+
+break_unlocked:
+	/* Release the simple reader lock, */
+	clear_bit(0, &ctx->in_lock);
+
+	if ((read > 0) && ((ret == 0) || (ret == -EAGAIN) || (ret == -ETIMEDOUT) || (ret == -EINTR)))
+		ret = read;
+
+	return ret;
+}
+
+static void
+rt_imx_mxs_auart_cleanup_ctx(struct rt_imx_mxs_auart_ctx *ctx)
+{
+	rtdm_event_destroy(&ctx->in_event);
+	rtdm_event_destroy(&ctx->out_event);
+	rtdm_event_destroy(&ctx->ioc_event);
+	rtdm_mutex_destroy(&ctx->out_lock);
+}
+
+static int
+rt_imx_mxs_auart_close(struct rtdm_dev_context *context, rtdm_user_info_t *user_info)
+{
+	struct rt_imx_mxs_auart_ctx *ctx;
+	struct rt_imx_mxs_auart_port *port;
+	uint64_t *in_history;
+	rtdm_lockctx_t lock_ctx;
+
+	ctx = (struct rt_imx_mxs_auart_ctx *)context->dev_private;
+
+	rtdm_lock_get_irqsave(&ctx->lock, lock_ctx);
+
+	port = ctx->port;
+
+	__raw_writel(BM_UARTAPP_CTRL0_SFTRST, port->port.membase + HW_UARTAPP_CTRL0_SET);
+
+	__raw_writel(BM_UARTAPP_INTR_RXIEN | BM_UARTAPP_INTR_RTIEN | BM_UARTAPP_INTR_CTSMIEN, port->port.membase + HW_UARTAPP_INTR_CLR);
+
+	in_history = ctx->in_history;
+	ctx->in_history = NULL;
+
+	rtdm_lock_put_irqrestore(&ctx->lock, lock_ctx);
+
+	rtdm_irq_free(&ctx->irq_handle);
+	rt_imx_mxs_auart_cleanup_ctx(ctx);
+
+	if (in_history)
+		kfree(in_history);
+
+	return 0;
+}
+
+static int
+rt_imx_mxs_auart_open(struct rtdm_dev_context *context, rtdm_user_info_t *user_info, int oflags)
+{
+	struct rt_imx_mxs_auart_ctx *ctx;
+	struct rt_imx_mxs_auart_port *port;
+	int ret;
+	uint64_t *dummy;
+
+	ctx = (struct rt_imx_mxs_auart_ctx *)context->dev_private;
+	ctx->port = (struct rt_imx_mxs_auart_port *)context->device->device_data;
+	port = ctx->port;
+
+	/* IPC initialisation - cannot fail with these parameters */
+	rtdm_lock_init(&ctx->lock);
+	rtdm_event_init(&ctx->in_event, 0);
+	rtdm_event_init(&ctx->out_event, 0);
+	rtdm_event_init(&ctx->ioc_event, 0);
+	rtdm_mutex_init(&ctx->out_lock);
+
+	ctx->in_head = 0;
+	ctx->in_tail = 0;
+	ctx->in_npend = 0;
+	ctx->in_nwait = 0;
+	ctx->in_lock = 0;
+	ctx->in_history = NULL;
+
+	ctx->out_head = 0;
+	ctx->out_tail = 0;
+	ctx->out_npend = 0;
+
+	ctx->ioc_events = 0;
+	ctx->ioc_event_lock = 0;
+	ctx->status = 0;
+	ctx->saved_errors = 0;
+
+	rt_imx_mxs_auart_reset(&port->port);
+
+	__raw_writel(BM_UARTAPP_CTRL2_UARTEN, port->port.membase + HW_UARTAPP_CTRL2_SET);
+
+	__raw_writel(BM_UARTAPP_INTR_RXIEN | BM_UARTAPP_INTR_RTIEN, port->port.membase + HW_UARTAPP_INTR);
+
+	__raw_writel(BM_UARTAPP_INTR_CTSMIEN, port->port.membase + HW_UARTAPP_INTR_SET);
+
+	/*
+	 * Enable the FIFO so all four bytes of a DMA word are written to
+	 * output (otherwise, only the LSB is written, i.e. 1 in 4 bytes)
+	 *
+	 * FIXME: Is it OK?
+	 */
+	__raw_writel(BM_UARTAPP_LINECTRL_FEN, port->port.membase + HW_UARTAPP_LINECTRL_SET);
+
+	rt_imx_mxs_auart_set_config(ctx, &default_config, &dummy);
+
+	ret = rtdm_irq_request(&ctx->irq_handle, port->port.irq, rt_imx_mxs_auart_irq_handle, 0, context->device->proc_name, ctx);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static const struct rtdm_device __initdata device_tmpl = {
+	.struct_version		= RTDM_DEVICE_STRUCT_VER,
+
+	.device_flags		= RTDM_NAMED_DEVICE | RTDM_EXCLUSIVE,
+	.context_size		= sizeof(struct rt_imx_mxs_auart_ctx),
+	.device_name		= "",
+
+	.open_nrt		= rt_imx_mxs_auart_open,
+
+	.ops = {
+		.close_nrt	= rt_imx_mxs_auart_close,
+		.ioctl_rt	= rt_imx_mxs_auart_ioctl,
+		.ioctl_nrt	= rt_imx_mxs_auart_ioctl,
+		.read_rt	= rt_imx_mxs_auart_read,
+		.write_rt	= rt_imx_mxs_auart_write,
+	},
+
+	.device_class		= RTDM_CLASS_SERIAL,
+	.device_sub_class	= RTDM_SUBCLASS_16550A,
+	.profile_version	= RTSER_PROFILE_VER,
+	.driver_name		= DRIVER_NAME,
+	.driver_version		= RTDM_DRIVER_VER(1, 0, 0),
+	.peripheral_name	= "IMX MXS application UART",
+	.provider_name		= "MECT s.r.l.",
+};
+
+static int __devinit
+rt_imx_mxs_auart_probe(struct platform_device *pdev)
+{
+	struct rtdm_device *dev;
+	u32 version;
+	int i;
+	int err = 0;
+	struct mxs_auart_plat_data *pdata;	// plat
+	struct rt_imx_mxs_auart_port *port;	// s
+	struct resource *res;			// r
+
+	port = kzalloc(sizeof(struct rt_imx_mxs_auart_port), GFP_KERNEL);
+	if (!port)
+		return -ENOMEM;
+
+	pdata = pdev->dev.platform_data;
+	if (pdata == NULL) {
+		err = -ENOMEM;
+		goto kfree_out;
+	}
+
+	if (pdata && pdata->clk)
+		port->clk = clk_get(NULL, pdata->clk);
+	else
+		port->clk = clk_get(NULL, "uart");
+	if (IS_ERR(port->clk)) {
+		err = PTR_ERR(port->clk);
+		goto kfree_out;
+	}
+
+	clk_enable(port->clk);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		err = -ENXIO;
+		goto clk_disable_out;
+	}
+
+	port->port.mapbase = res->start;
+	port->port.fifosize = pdata->fifo_size;
+	port->port.timeout = pdata->timeout ? pdata->timeout : (HZ / 10);
+	port->port.uartclk = clk_get_rate(port->clk);
+
+	port->port.dev = port->dev = get_device(&pdev->dev);
+
+	port->flags = 0;
+
+	if (!request_mem_region(port->port.mapbase, PAGE_SIZE, DRIVER_NAME)) {
+		err = -EBUSY;
+		goto clk_disable_out;
+	}
+
+	/* FIXME IMX-yes, MXS-no */
+	port->port.membase = ioremap(port->port.mapbase, PAGE_SIZE);
+	if (!port->port.membase) {
+		err = -ENOMEM;
+		goto release_mem_region_out;	// FIXME Sync with flow above.
+	}
+
+	for (i = 0; i < ARRAY_SIZE(port->irq); i++) {
+		port->irq[i] = platform_get_irq(pdev, i);
+		if (port->irq[i] < 0) {
+			err = port->irq[i];
+			goto iounmap_out;	// FIXME Sync with flow above.
+		}
+	}
+
+	port->port.irq = port->irq[0];
+
+	/* RTDM */
+	dev = &port->rtdm_dev;
+
+	memcpy(dev, &device_tmpl, sizeof(struct rtdm_device));
+
+	snprintf(dev->device_name, RTDM_MAX_DEVNAME_LEN, "rtser%d", pdev->id);
+	dev->proc_name = dev->device_name;
+	dev->device_id = pdev->id;
+	dev->device_data = port;
+
+	pdata = pdev->dev.platform_data;
+
+	err = rtdm_dev_register(dev);
+	if (err)
+		goto iounmap_out;
+
+	port->use_hwflow = 1;
+
+	platform_set_drvdata(pdev, port);
+
+	device_init_wakeup(&pdev->dev, 1);
+
+	version = __raw_readl(port->port.membase + HW_UARTAPP_VERSION);
+	printk(
+		KERN_INFO
+		"%s on Xenomai RTDM MXS APPUART%d (v%d.%d.%d): membase=0x%p mapbase=%#x irq=%d uartclk=%d\n",
+		dev->device_name,
+		pdev->id,
+		(version >> 24) & 0xFF,
+		(version >> 16) & 0xFF,
+		version & 0xFFFF,
+		port->port.membase,
+		(u32)port->port.mapbase,
+		port->port.irq,
+		port->port.uartclk
+	);
+
+	return 0;
+
+iounmap_out:
+	iounmap(port->port.membase);
+
+release_mem_region_out:
+	release_mem_region(port->port.mapbase, SZ_4K);
+
+clk_disable_out:
+	if (!IS_ERR(port->clk)) {
+		clk_put(port->clk);
+		clk_disable(port->clk);
+	}
+
+kfree_out:
+	kfree(port);
+
+	return err;
+}
+
+static int __devexit
+rt_imx_mxs_auart_remove(struct platform_device *pdev)
+{
+	struct mxsauart_platform_data *pdata;
+	struct rt_imx_mxs_auart_port *port = platform_get_drvdata(pdev);	// s
+	struct rtdm_device *dev = &port->rtdm_dev;
+
+	pdata = pdev->dev.platform_data;
+	platform_set_drvdata(pdev, NULL);
+
+	rtdm_dev_unregister(dev, 1000);
+
+	if (port) {
+		put_device(port->dev);
+
+		if (port->clk) {
+			clk_disable(port->clk);
+			clk_put(port->clk);
+		}
+
+		iounmap(port->port.membase);
+
+		release_mem_region(port->port.mapbase, PAGE_SIZE);
+
+		kfree(port);
+	}
+
+	return 0;
+}
+
+static const struct platform_device_id rt_imx_mxs_auart_id_table[] = {
+	{"mxs-auart",},
+	{},
+};
+
+static struct platform_driver rt_imx_mxs_auart_driver = {
+	.probe = rt_imx_mxs_auart_probe,
+	.remove = __devexit_p(rt_imx_mxs_auart_remove),
+	.id_table = rt_imx_mxs_auart_id_table,
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init
+rt_imx_mxs_auart_init(void)
+{
+	return platform_driver_register(&rt_imx_mxs_auart_driver);
+}
+
+static void __exit
+rt_imx_mxs_auart_exit(void)
+{
+	platform_driver_unregister(&rt_imx_mxs_auart_driver);
+}
+
+module_init(rt_imx_mxs_auart_init)
+module_exit(rt_imx_mxs_auart_exit)
+
+MODULE_AUTHOR("Mihai Lazarescu <mlazarescu@mect.it>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Freescale MXS application UART Xenomai RTDM driver");
