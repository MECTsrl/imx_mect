diff -ruN rpm/BUILD/linux-2.6.35.3-xenomai-2.6.0/xenomai-2.6.0/ksrc/drivers/serial/rt_imx_mxs_auart.c rpm/BUILD/tmp/linux-2.6.35.3-xenomai-2.6.0/xenomai-2.6.0/ksrc/drivers/serial/rt_imx_mxs_auart.c
--- rpm/BUILD/linux-2.6.35.3-xenomai-2.6.0/xenomai-2.6.0/ksrc/drivers/serial/rt_imx_mxs_auart.c	2016-10-21 22:05:01.768362021 +0200
+++ rpm/BUILD/tmp/linux-2.6.35.3-xenomai-2.6.0/xenomai-2.6.0/ksrc/drivers/serial/rt_imx_mxs_auart.c	2016-10-20 13:39:40.251711892 +0200
@@ -146,6 +146,315 @@
 static int rt_imx_mxs_auart_set_config(struct rt_imx_mxs_auart_ctx *ctx, const struct rtser_config *config, uint64_t **in_history_ptr);
 
 
+
+/* ------------------ GPIO debug ------------------ */
+
+#define RTS_CFG_DEBUG_GPIO
+
+#if defined(RTS_CFG_DEBUG_GPIO)
+
+// PINCTRL register in "i.MX28 Applications Processor Reference Manual", # MCIMX28RM, rev. 1, 2010, page 125
+#define XX_GPIO_ADDR        0xF0018000
+#define XX_GPIO_SET_OFFSET  0x0004
+#define XX_GPIO_CLR_OFFSET  0x0008
+#define XX_GPIO_DIN_OFFSET  0x0000
+
+/* Use SDCARD pins as GPIO */
+#define XX_GPIO_SDCARD		1
+
+#ifdef XX_GPIO_SDCARD
+
+/*
+ * GPIO INDEX LAYOUT
+ *
+ * OUTPUTS:  0               ->  (XX_MAX_OUT_BIT - 1)
+ * INPUTS:   XX_MAX_OUT_BIT  ->  (XX_MAX_OUT_BIT + XX_MAX_IN_BIT - 1)
+ */
+#define XX_MAX_OUT_BIT 6
+#define XX_MAX_IN_BIT 0
+
+#else
+
+#define XX_MAX_OUT_BIT 8
+#define XX_MAX_IN_BIT 0
+
+#endif
+
+static void *xx_base_ptr = NULL;
+static struct {
+	unsigned offset;
+	unsigned value;
+} xx_gpio_enabler[] = {
+	// PINCTRL register in "i.MX28 Applications Processor Reference Manual", # MCIMX28RM, rev. 1, 2010, page 688
+
+#ifdef XX_GPIO_SDCARD
+
+	// [0] OUT: bank 2, pin 2 (pin 2, SSP0_DATA2)
+	// 5 4 G 3 V 2 1 X
+	{ 0x0144, 0x00000030 },		//MUXSELx SET(GPIO), page 699
+	{ 0x0384, 0x00000400 },		//DRIVEx SET(3.3V), page 753, 756
+	{ 0x03b8, 0x00000300 },		//DRIVEx CLR(4mA), page 753, 756
+	{ 0x0628, 0x00000004 },		//PULLx CLR(no), page 789
+	{ 0x0728, 0x00000004 },		//DOUTx CLR, page 801
+	{ 0x0b24, 0x00000004 },		//DOEx SET(en.), page 810
+
+	// [1] OUT: bank 2, pin 3 (pin 274, SSP0_DATA3)
+	// 5 4 G 3 V 2 X 0
+	{ 0x0144, 0x000000c0 },		//MUXSELx SET(GPIO), page 699
+	{ 0x0384, 0x00004000 },		//DRIVEx SET(3.3V), page 753, 756
+	{ 0x03a8, 0x00003000 },		//DRIVEx CLR(4mA), page 753, 756
+	{ 0x0628, 0x00000008 },		//PULLx CLR(no), page 789
+	{ 0x0728, 0x00000008 },		//DOUTx CLR, page 801
+	{ 0x0b24, 0x00000008 },		//DOEx SET(en.), page 810
+
+	// [2] OUT: bank 2, pin 8 (pin 276, SSP0_CMD)
+	// 5 4 G 3 V X 1 0
+	{ 0x0144, 0x00030000 },		//MUXSELx SET(GPIO), page 699
+	{ 0x0394, 0x00000004 },		//DRIVEx SET(3.3V), page 753, 756
+	{ 0x03a8, 0x00000003 },		//DRIVEx CLR(4mA), page 753, 756
+	{ 0x0628, 0x00000100 },		//PULLx CLR(no), page 789
+	{ 0x0728, 0x00000100 },		//DOUTx CLR, page 801
+	{ 0x0b24, 0x00000100 },		//DOEx SET(en.), page 810
+
+	// [3] OUT: bank 2, pin 10 (pin 268, SSP0_SCK)
+	// 5 4 G X V 2 1 0
+	{ 0x0144, 0x00300000 },		//MUXSELx SET(GPIO), page 699
+	{ 0x0394, 0x00000400 },		//DRIVEx SET(3.3V), page 753, 756
+	{ 0x03a8, 0x00000300 },		//DRIVEx CLR(4mA), page 753, 756
+	{ 0x0628, 0x00000400 },		//PULLx CLR(no), page 789
+	{ 0x0728, 0x00000400 },		//DOUTx CLR, page 801
+	{ 0x0b24, 0x00000400 },		//DOEx SET(en.), page 810
+
+	// [4] OUT: bank 2, pin 0 (pin 270, SSP0_DATA0)
+	// 5 X G 3 V 2 1 0
+	{ 0x0144, 0x00000003 },		//MUXSELx SET(GPIO), page 699
+	{ 0x0384, 0x00000004 },		//DRIVEx SET(3.3V), page 753, 756
+	{ 0x03b8, 0x00000003 },		//DRIVEx CLR(4mA), page 753, 756
+	{ 0x0628, 0x00000001 },		//PULLx CLR(no), page 789
+	{ 0x0728, 0x00000001 },		//DOUTx CLR, page 801
+	{ 0x0b24, 0x00000001 },		//DOEx SET(en.), page 810
+
+	// [5] IN : bank 2, pin 1 (pin 289, SSP0_DATA1)
+	// X 4 G 3 V 2 1 0
+	{ 0x0144, 0x0000000c },		//MUXSELx SET(GPIO), page 699
+	{ 0x0384, 0x00000040 },		//DRIVEx SET(3.3V), page 753, 756
+	{ 0x0398, 0x00000030 },		//DRIVEx CLR(4mA), page 753, 756
+	{ 0x0628, 0x00000002 },		//PULLx CLR(no), page 789
+	{ 0x0728, 0x00000002 },		//DOUTx CLR, page 801
+//	{ 0x0b28, 0x00000002 },		//DOEx CLR(en.), page 810 (if input)
+	{ 0x0b24, 0x00000002 },		//DOEx SET(en.), page 810 (if output)
+
+#else
+
+	// FGPIO_1 OUT: bank 2, pin 14 (pin 21, SSP1_DATA0)
+	{ 0x0144, 0x30000000 },		//MUXSEL4 SET(GPIO), page 705
+	{ 0x0394, 0x04000000 },		//DRIVE9 SET(3.3V), page 756
+	{ 0x0398, 0x03000000 },		//DRIVE9 CLR(4mA), page 756
+	{ 0x0628, 0x00004000 },		//PULL2 CLR(no), page 789
+	{ 0x0728, 0x00004000 },		//DOUT2 CLR, page 801
+	{ 0x0b24, 0x00004000 },		//DOE2 SET(en.), page 810
+
+	// FGPIO_2 OUT: bank 0, pin 17 (pin 131, GPMI_CE1N)
+	{ 0x0114, 0x0000000c },		//MUXSEL1 SET(GPIO), page 696
+	{ 0x0324, 0x00000040 },		//DRIVE2 SET(3.3V), page 734
+	{ 0x0328, 0x00000030 },		//DRIVE2 CLR(4mA), page 734
+	{ 0x0608, 0x00020000 },		//PULL0 CLR(no), page 785
+	{ 0x0708, 0x00020000 },		//DOUT0 CLR, page 800
+	{ 0x0b04, 0x00020000 },		//DOEx SET(en.), page 810
+
+	// FGPIO_3 OUT: bank 2, pin 12 (pin 11, SSP1_SCK)
+	{ 0x0144, 0x03000000 },		//MUXSEL4 SET(GPIO), page 699
+	{ 0x0394, 0x00040000 },		//DRIVE9 SET(3.3V), page 756
+	{ 0x0398, 0x00030000 },		//DRIVE9 CLR(4mA), page 756
+	{ 0x0628, 0x00001000 },		//PULL2 CLR(no), page 789
+	{ 0x0728, 0x00001000 },		//DOUT2 CLR, page 801
+	{ 0x0b24, 0x00001000 },		//DOE2 SET(en.), page 810
+
+	// FGPIO_4 OUT: bank 3, pin 6 (pin 78, AUART1_CTS)
+	{ 0x0164, 0x00003000 },		//MUXSEL6 SET(GPIO), page 710
+	{ 0x03c4, 0x04000000 },		//DRIVE12 SET(3.3V), page 764
+	{ 0x03c8, 0x03000000 },		//DRIVEx CLR(4mA), page 764
+	{ 0x0638, 0x00000040 },		//PULL3 CLR(no), page 791
+	{ 0x0738, 0x00000040 },		//DOUT3 CLR, page 802
+	{ 0x0b34, 0x00000040 },		//DOE3 SET(en.), page 810
+
+	// FGPIO_5 OUT: bank 2, pin 20 (pin 7, SSP2_SS1)
+	{ 0x0154, 0x00000300 },		//MUXSEL5 SET(GPIO), page 708
+	{ 0x03a4, 0x00040000 },		//DRIVE10 SET(3.3V), page 760
+	{ 0x03a8, 0x00030000 },		//DRIVE10 CLR(4mA), page 760
+	{ 0x0628, 0x00100000 },		//PULL2 CLR(no), page 791
+	{ 0x0728, 0x00100000 },		//DOUT2 CLR, page 801
+	{ 0x0b24, 0x00100000 },		//DOE2 SET(en.), page 810
+
+	// FGPIO_6 OUT: bank 3, pin 2 (pin 70, AUART0_CTS)
+	{ 0x0164, 0x00000030 },		//MUXSEL6 SET(GPIO), page 711
+	{ 0x03c4, 0x00000400 },		//DRIVE12 SET(3.3V), page 764
+	{ 0x03c8, 0x00000300 },		//DRIVE12 CLR(4mA), page 764
+	{ 0x0638, 0x00000004 },		//PULL3 CLR(no), page 791
+	{ 0x0738, 0x00000004 },		//DOUT3 CLR, page 802
+	{ 0x0b34, 0x00000004 },		//DOE3 SET(en.), page 811
+
+	// FGPIO_7 OUT: bank 3, pin 4 (pin 81, AUART1_RX)
+	{ 0x0164, 0x00000300 },		//MUXSEL6 SET(GPIO), page 710
+	{ 0x03c4, 0x00040000 },		//DRIVE12 SET(3.3V), page 764
+	{ 0x03c8, 0x00030000 },		//DRIVE12 CLR(4mA), page 764
+	{ 0x0638, 0x00000010 },		//PULL3 CLR(no), page 791
+	{ 0x0738, 0x00000010 },		//DOUT3 CLR, page 802
+	{ 0x0b34, 0x00000010 },		//DOE3 SET(en.), page 810
+
+	// FGPIO_8 OUT: bank 3, pin 5 (pin 65, AUART1_TX)
+	{ 0x0164, 0x00000c00 },		//MUXSEL6 SET(GPIO), page 710
+	{ 0x03c4, 0x00400000 },		//DRIVE12 SET(3.3V), page 764
+	{ 0x03c8, 0x00300000 },		//DRIVE12 CLR(4mA), page 764
+	{ 0x0638, 0x00000020 },		//PULL3 CLR(no), page 791
+	{ 0x0738, 0x00000020 },		//DOUT3 CLR, page 802
+	{ 0x0b34, 0x00000020 },		//DOE3 SET(en.), page 810
+
+#endif
+
+	// THE END
+	{ 0xffff, 0xffffffff }
+};
+static struct {
+	unsigned offset;
+	unsigned mask;
+} xx_gpio_pin[] = {
+	// PINCTRL register in "i.MX28 Applications Processor Reference Manual", # MCIMX28RM, rev. 1, 2010, page 688
+
+#ifdef XX_GPIO_SDCARD
+
+	// [0] OUT: bank 2, pin  2 (pin   2, SSP0_DATA2)
+	// 5 4 G 3 V 2 1 X
+	{ 0x0720, 0x00000004 },		//DOUTx, page 801
+
+	// [1] OUT: bank 2, pin  3 (pin 274, SSP0_DATA3)
+	// 5 4 G 3 V 2 X 0
+	{ 0x0720, 0x00000008 },		//DOUTx, page 801
+
+	// [2] OUT: bank 2, pin  8 (pin 276, SSP0_CMD)
+	// 5 4 G 3 V X 1 0
+	{ 0x0720, 0x00000100 },		//DOUTx, page 801
+
+	// [3] OUT: bank 2, pin 10 (pin 268, SSP0_SCK)
+	// 5 4 G X V 2 1 0
+	{ 0x0720, 0x00000400 },		//DOUTx, page 801
+
+	// [4] OUT: bank 2, pin  0 (pin 270, SSP0_DATA0)
+	// 5 X G 3 V 2 1 0
+	{ 0x0720, 0x00000001 },		//DOUTx, page 801
+
+	// [5] IN:  bank 2, pin  1 (pin 289, SSP0_DATA1)
+	// X 4 G 3 V 2 1 0
+	//{ 0x0920, 0x00000002 },	//DINx, page 806
+	{ 0x0720, 0x00000002 },		//DOUTx, page 801
+
+#else
+
+	// FGPIO_1 OUT: bank 2, pin 14 (pin 21, SSP1_DATA0)
+	{ 0x0720, 0x00004000 },		//DOUT2, page 801
+
+	// FGPIO_2 OUT: bank 0, pin 17 (pin 131, GPMI_CE1N)
+	{ 0x0700, 0x00020000 },		//DOUTx, page 801
+
+	// FGPIO_3 OUT: bank 2, pin 12 (pin 11, SSP1_SCK)
+	{ 0x0720, 0x00001000 },		//DOUT2, page 801
+
+	// FGPIO_4 OUT: bank 3, pin 6 (pin 78, AUART1_CTS)
+	{ 0x0730, 0x00000040 },		//DOUT3, page 802
+
+	// FGPIO_5 OUT: bank 2, pin 20 (pin 7, SSP2_SS1)
+	{ 0x0720, 0x00100000 },		//DOUT2, page 801
+
+	// FGPIO_6 OUT: bank 3, pin 2 (pin 70, AUART0_CTS)
+	{ 0x0730, 0x00000002 },		//DOUT3, page 801
+
+	// FGPIO_7 OUT: bank 3, pin 4 (pin 81, AUART1_RX)
+	{ 0x0730, 0x00000010 },		//DOUT3, page 801
+
+	// FGPIO_8 OUT: bank 3, pin 5 (pin 65, AUART1_TX)
+	{ 0x0730, 0x00000020 },		//DOUT3, page 801
+
+#endif
+
+	// THE END
+	{ 0xffff, 0xffffffff }
+};
+
+
+void
+xx_gpio_set(unsigned n)
+{
+	if (xx_base_ptr && n < XX_MAX_OUT_BIT) {
+		register unsigned *reg_ptr;
+
+		reg_ptr = (unsigned *)(xx_base_ptr + xx_gpio_pin[n].offset + XX_GPIO_SET_OFFSET);
+		*reg_ptr = xx_gpio_pin[n].mask;
+	}
+}
+
+void
+xx_gpio_clr(unsigned n)
+{
+	if (xx_base_ptr && n < XX_MAX_OUT_BIT) {
+		register unsigned *reg_ptr;
+
+		reg_ptr = (unsigned *)(xx_base_ptr + xx_gpio_pin[n].offset + XX_GPIO_CLR_OFFSET);
+		*reg_ptr = xx_gpio_pin[n].mask;
+	}
+}
+
+/**
+ * Read the level of the given GPIO pin ID.
+ *
+ * @param n				pin ID to read.
+ *
+ * @return				pin level.
+ */
+unsigned char
+xx_gpio_get(unsigned n)
+{
+	if ((xx_base_ptr == NULL) || (n < XX_MAX_OUT_BIT) || (n >= (XX_MAX_OUT_BIT + XX_MAX_IN_BIT)))
+		return 0;
+
+	return (*((unsigned *)(xx_base_ptr + xx_gpio_pin[n].offset + XX_GPIO_DIN_OFFSET)) & xx_gpio_pin[n].mask) ? 1 : 0;
+}
+
+void
+xx_gpio_init(void)
+{
+	unsigned i = 0;
+	unsigned *reg_ptr = NULL;
+
+	xx_base_ptr = (void *)XX_GPIO_ADDR;
+
+	// Set up all input and output pins.
+	for (i = 0; xx_gpio_enabler[i].offset < 0xffff; i++) {
+		reg_ptr = (unsigned *)(xx_base_ptr + xx_gpio_enabler[i].offset);
+		*reg_ptr = xx_gpio_enabler[i].value;
+	}
+
+#if 0
+	// Toggle all output pins, leaving them ON
+	for (i = 0; i < XX_MAX_OUT_BIT; ++i) {
+		xx_gpio_clr(i);
+		xx_gpio_set(i);
+		xx_gpio_clr(i);
+	}
+#endif
+}
+
+void
+xx_gpio_close(void)
+{
+	xx_base_ptr = NULL;
+}
+
+#endif
+
+/* ------------------ GPIO debug ------------------ */
+
+
+
 void rts_deassert_func(struct rt_alarm *rts_deassert, void *data)
 {
 	struct rt_imx_mxs_auart_ctx *ctx = (struct rt_imx_mxs_auart_ctx *)data;
@@ -566,17 +875,25 @@
 	 * NB: RTIS helps in getting here as soon as the data ended and the FIFO was not yet full
 	 */
 	if (istat & (BM_UARTAPP_INTR_OEIS | BM_UARTAPP_INTR_BEIS | BM_UARTAPP_INTR_PEIS | BM_UARTAPP_INTR_FEIS | BM_UARTAPP_INTR_RXIS | BM_UARTAPP_INTR_RTIS)) {
+		xx_gpio_set(0);
+
 		__raw_writel((BM_UARTAPP_INTR_OEIS | BM_UARTAPP_INTR_BEIS | BM_UARTAPP_INTR_PEIS | BM_UARTAPP_INTR_FEIS | BM_UARTAPP_INTR_RTIS | BM_UARTAPP_INTR_RXIS), port->port.membase + HW_UARTAPP_INTR_CLR);
 		rbytes += rt_imx_mxs_auart_rx_chars(ctx, &timestamp);
 		events |= RTSER_EVENT_RXPEND;
 		retval = RTDM_IRQ_HANDLED;
+
+		xx_gpio_clr(0);
 	}
 
 	/* TX ready */
 	if (istat & BM_UARTAPP_INTR_TXIS) {
+		xx_gpio_set(1);
+
 		__raw_writel(BM_UARTAPP_INTR_TXIS, port->port.membase + HW_UARTAPP_INTR_CLR);
 		rt_imx_mxs_auart_tx_chars(ctx); /* this call from the irq handler */
 		retval = RTDM_IRQ_HANDLED;
+
+		xx_gpio_clr(1);
 	}
 
 	/* Modem CTS */
@@ -925,11 +1242,19 @@
 	rtdm_toseq_t timeout_seq;
 	ssize_t ret;
 
-	if (nbyte == 0)
+	xx_gpio_set(2);
+
+	if (nbyte == 0) {
+		xx_gpio_clr(2);
+
 		return 0;
+	}
+
+	if (user_info && !rtdm_read_user_ok(user_info, buf, nbyte)) {
+		xx_gpio_clr(2);
 
-	if (user_info && !rtdm_read_user_ok(user_info, buf, nbyte))
 		return -EFAULT;
+	}
 
 	ctx = (struct rt_imx_mxs_auart_ctx *)context->dev_private;
 
@@ -937,8 +1262,11 @@
 
 	/* Make write operation atomic. */
 	ret = rtdm_mutex_timedlock(&ctx->out_lock, ctx->config.tx_timeout, &timeout_seq);
-	if (ret)
+	if (ret) {
+		xx_gpio_clr(2);
+
 		return ret;
+	}
 
 	while (nbyte > 0) {
 		rtdm_lock_get_irqsave(&ctx->lock, lock_ctx);
@@ -1003,13 +1331,19 @@
 
 		ret = rtdm_event_timedwait(&ctx->out_event, ctx->config.tx_timeout, &timeout_seq);
 		if (ret < 0) {
-			if (ret == -EIDRM)
+			if (ret == -EIDRM) {
+				xx_gpio_clr(2);
+
 				/* Device has been closed - return immediately. */
 				return -EBADF;
+			}
+
+			if (ret == -EWOULDBLOCK) {
+				xx_gpio_clr(2);
 
-			if (ret == -EWOULDBLOCK)
 				/* Fix error code for non-blocking mode. */
 				ret = -EAGAIN;
+			}
 
 			break;
 		}
@@ -1020,6 +1354,8 @@
 	if ((written > 0) && ((ret == 0) || (ret == -EAGAIN) || (ret == -ETIMEDOUT) || (ret == -EINTR)))
 		ret = written;
 
+	xx_gpio_clr(2);
+
 	return ret;
 }
 
@@ -1038,11 +1374,19 @@
 	ssize_t ret = -EAGAIN;	/* for non-blocking read */
 	int nonblocking;
 
-	if (nbyte == 0)
+	xx_gpio_set(3);
+
+	if (nbyte == 0) {
+		xx_gpio_clr(3);
+
 		return 0;
+	}
+
+	if (user_info && !rtdm_rw_user_ok(user_info, buf, nbyte)) {
+		xx_gpio_clr(3);
 
-	if (user_info && !rtdm_rw_user_ok(user_info, buf, nbyte))
 		return -EFAULT;
+	}
 
 	ctx = (struct rt_imx_mxs_auart_ctx *)context->dev_private;
 
@@ -1052,8 +1396,11 @@
 	nonblocking = (ctx->config.rx_timeout < 0);
 
 	/* only one reader allowed, stop any further attempts here */
-	if (test_and_set_bit(0, &ctx->in_lock))
+	if (test_and_set_bit(0, &ctx->in_lock)) {
+		xx_gpio_clr(3);
+
 		return -EBUSY;
+	}
 
 	rtdm_lock_get_irqsave(&ctx->lock, lock_ctx);
 
@@ -1138,9 +1485,12 @@
 
 		ret = rtdm_event_timedwait(&ctx->in_event, ctx->config.rx_timeout, &timeout_seq);
 		if (ret < 0) {
-			if (ret == -EIDRM)
+			if (ret == -EIDRM) {
+				xx_gpio_clr(3);
+
 				/* Device has been closed - return immediately. */
 				return -EBADF;
+			}
 
 			rtdm_lock_get_irqsave(&ctx->lock, lock_ctx);
 
@@ -1166,6 +1516,8 @@
 	if ((read > 0) && ((ret == 0) || (ret == -EAGAIN) || (ret == -ETIMEDOUT) || (ret == -EINTR)))
 		ret = read;
 
+	xx_gpio_clr(3);
+
 	return ret;
 }
 
@@ -1396,7 +1748,7 @@
 	version = __raw_readl(port->port.membase + HW_UARTAPP_VERSION);
 	printk(
 		KERN_INFO
-		"%s on Xenomai RTDM MXS APPUART%d (v%d.%d.%d): membase=0x%p mapbase=%#x irq=%d uartclk=%d\n",
+		"GPIO %s on Xenomai RTDM MXS APPUART%d (v%d.%d.%d): membase=0x%p mapbase=%#x irq=%d uartclk=%d\n",
 		dev->device_name,
 		pdev->id,
 		(version >> 24) & 0xFF,
@@ -1408,6 +1760,8 @@
 		port->port.uartclk
 	);
 
+	xx_gpio_init();
+
 	return 0;
 
 clk_disable_out:
@@ -1428,6 +1782,8 @@
 	struct rt_imx_mxs_auart_port *port; // s
 	struct rtdm_device *dev;
 
+	xx_gpio_close();
+
 	port = platform_get_drvdata(pdev);
 	platform_set_drvdata(pdev, NULL);
 
